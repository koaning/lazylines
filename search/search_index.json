{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>Lazylines is a small Python library that makes it easier to work with lists of dictionaries as well as JSONL files. It was originally designed to help handle some boilerplate for some of my custom Prodigy recipes.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>To give a demo of what the base useage might look like, let's download a .jsonl file. </p> <pre><code>wget https://calmcode.io/datasets/pokemon.jsonl\n</code></pre> <p>This file has data that looks like this: </p> <pre><code>{\"attack\": 49, \"hp\": 45, \"name\": \"Bulbasaur\", \"total\": 318, \"type\": [\"Grass\", \"Poison\"]}\n{\"attack\": 62, \"hp\": 60, \"name\": \"Ivysaur\", \"total\": 405, \"type\": [\"Grass\", \"Poison\"]}\n</code></pre> <pre><code>from lazylines import read_jsonl\n\n(\n    read_jsonl(\"tests/pokemon.jsonl\")\n      .unnest(\"type\")\n      .nest_by(\"type\")\n      .mutate(count=lambda d: len(d['subset']))\n      .drop(\"subset\")\n      .collect()\n)\n</code></pre> <p>Let's go through everything happening line-by-line. </p> <ol> <li>First we read the file with <code>read_jsonl</code>. Internally, it's stored as a generator, so no data is actually being read just yet. </li> <li>Next, we unnest the list in the <code>\"type\"</code> key. This turns an item with a nested example into two examples each containing one of the nested items.  </li> <li>Next, we nest by the type again. This allows us to have an item for each <code>\"type\"</code> together with a <code>\"subset\"</code> key that contains all relevant examples that belong to the <code>\"type\"</code>. </li> <li>Next, we add a key called <code>\"count\"</code> by calculating the length of the subset. </li> <li>Next, we drop the <code>\"subset\"</code> key. </li> <li>Finally, we <code>collect()</code> the data. All the previous steps were \"lazy\", only when we call <code>collect()</code> do we actually perform the operations in the chain. </li> </ol> <p>This is what the output looks like. </p> <pre><code>[{'type': 'Grass', 'count': 95},\n {'type': 'Poison', 'count': 62},\n {'type': 'Fire', 'count': 64},\n {'type': 'Flying', 'count': 101},\n {'type': 'Dragon', 'count': 50},\n {'type': 'Water', 'count': 126},\n {'type': 'Bug', 'count': 72},\n {'type': 'Normal', 'count': 102},\n {'type': 'Electric', 'count': 50},\n {'type': 'Ground', 'count': 67},\n {'type': 'Fairy', 'count': 40},\n {'type': 'Fighting', 'count': 53},\n {'type': 'Psychic', 'count': 90},\n {'type': 'Rock', 'count': 58},\n {'type': 'Steel', 'count': 49},\n {'type': 'Ice', 'count': 38},\n {'type': 'Ghost', 'count': 46},\n {'type': 'Dark', 'count': 51}]\n</code></pre> <p>There's a lot that you can do just by nesting and unnesting and this library tries to make it easy to perform common data wrangling tasks without having to resort to heavy dependencies.</p>"},{"location":"#fun-features","title":"Fun Features","text":"<p>There are a few fun features to mention out loud. </p>"},{"location":"#progress-bars","title":"Progress bars","text":"<p>If you have long running tasks you can keep track of the progress via the <code>.progress()</code> method. </p> <pre><code>import time \nfrom lazylines import read_jsonl\n\n(\n    read_jsonl(\"tests/pokemon.jsonl\")\n      .progress()\n      .foreach(lambda d: time.sleep(0.02))\n      .collect()\n)\n</code></pre> <p>The <code>foreach</code> method runs a function for each item and then returns the original item. The <code>progress</code> method adds the progress bar. </p>"},{"location":"#intermediate-results","title":"Intermediate results","text":"<p>It can help to \"see\" what is happening in each step in a pipeline.  For these use-cases you can use the <code>.show()</code> method. </p> <pre><code>from lazylines import read_jsonl\n\n(\n    read_jsonl(\"tests/pokemon.jsonl\")\n      .show(2)\n      .unnest(\"type\")\n      .show(2)\n)\n</code></pre> <p>The first call to <code>.show(2)</code> will render: </p> <pre><code>{'attack': 49,\n 'hp': 45,\n 'name': 'Bulbasaur',\n 'total': 318,\n 'type': ['Grass', 'Poison']}\n{'attack': 62,\n 'hp': 60,\n 'name': 'Ivysaur',\n 'total': 405,\n 'type': ['Grass', 'Poison']}\n</code></pre> <p>The second call to <code>.show(2)</code> will render: </p> <pre><code>{'attack': 49, 'hp': 45, 'name': 'Bulbasaur', 'total': 318, 'type': 'Grass'}\n{'attack': 49, 'hp': 45, 'name': 'Bulbasaur', 'total': 318, 'type': 'Poison'}\n</code></pre>"},{"location":"#learn-more","title":"Learn More","text":"<p>To learn more, check the API guide. </p>"},{"location":"api/","title":"API","text":""},{"location":"api/#lazylines.read_jsonl","title":"<code>lazylines.read_jsonl(path)</code>","text":"<p>Read .jsonl file and turn it into a LazyLines object.</p> Source code in <code>lazylines/__init__.py</code> <pre><code>def read_jsonl(path: str | Path) -&gt; LazyLines:\n    \"\"\"Read .jsonl file and turn it into a LazyLines object.\"\"\"\n    return LazyLines(srsly.read_jsonl(path))\n</code></pre>"},{"location":"api/#lazylines.LazyLines","title":"<code>lazylines.LazyLines</code>","text":"<p>An object that can wrangle iterables of dictionaries (similar to JSONL).</p> <pre><code>from lazylines import LazyLines\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>class LazyLines:\n    \"\"\"\n    An object that can wrangle iterables of dictionaries (similar to JSONL).\n\n    ```python\n    from lazylines import LazyLines\n    ```\n    \"\"\"\n\n    def __init__(self, g):\n        self.g = g\n        self.groups = set()\n\n    def cache(self) -&gt; LazyLines:\n        \"\"\"\n        Cache the result internally by turning it into a list.\n\n        It's recommended to store the result into another variable.\n\n        ```python\n        from lazylines import LazyLines\n\n        items = ({\"a\": i} for i in range(100))\n\n        # The output is still a LazyLines object, but the intermediate representation\n        # is now a list which might speedup repeated downstream tasks\n        cached = (LazyLines(items).cache())\n        ```\n        \"\"\"\n        return LazyLines(g=list(self.g))\n\n    def mutate(self, **kwargs: dict[str, Callable]) -&gt; LazyLines:\n        \"\"\"\n        Adds/overwrites keys in the dictionary based on lambda.\n\n        Arguments:\n            kwargs: str/callable pairs that represent keys and a function to calculate it's value\n\n        **Usage**:\n\n        ```python\n        from lazylines import LazyLines\n\n        items = [{\"a\": 2}, {\"a\": 3}]\n        results = (LazyLines(items).mutate(b=lambda d: d[\"a\"] * 2))\n        expected = [{\"a\": 2, \"b\": 4}, {\"a\": 3, \"b\": 6}]\n        assert results.collect() == expected\n        ```\n        \"\"\"\n\n        def new_gen():\n            for item in self.g:\n                for k, v in kwargs.items():\n                    item[k] = v(item)\n                yield item\n\n        return LazyLines(g=new_gen())\n\n    def keep(self, *args: Callable) -&gt; LazyLines:\n        \"\"\"\n        Only keep a subset of the items in the generator based on lambda.\n\n        Arguments:\n            args: functions that can be used to filter the data, if it outputs `True` it will be kept around\n\n        **Usage**:\n\n        ```python\n        from lazylines import LazyLines\n\n        items = [{\"a\": 2}, {\"a\": 3}]\n        results = (LazyLines(items).keep(lambda d: d[\"a\"] % 2 == 0))\n        expected = [{\"a\": 2}]\n        assert results.collect() == expected\n        ```\n        \"\"\"\n\n        def new_gen():\n            for item in self.g:\n                allowed = True\n                for func in args:\n                    if not func(item):\n                        allowed = False\n                if allowed:\n                    yield item\n\n        return LazyLines(g=new_gen())\n\n    def unnest(self, key: str = \"subset\") -&gt; LazyLines:\n        \"\"\"\n        Un-nests a list of dictionaries in a key\n\n        Arguments:\n            key: the key to un-nest\n\n        **Usage**:\n\n        ```python\n        from lazylines import LazyLines\n\n        data = [{'annotator': 'a',\n                 'subset': [{'accept': True, 'text': 'foo'},\n                            {'accept': True, 'text': 'foobar'}]},\n                {'annotator': 'b',\n                 'subset': [{'accept': True, 'text': 'foo'},\n                            {'accept': True, 'text': 'foobar'}]}]\n\n        expected = [\n            {'accept': True, 'annotator': 'a', 'text': 'foo'},\n            {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n            {'accept': True, 'annotator': 'b', 'text': 'foo'},\n            {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n        ]\n\n        result = LazyLines(data).unnest(\"subset\").collect()\n        assert result == expected\n        ```\n        \"\"\"\n\n        def new_gen():\n            for item in self.g:\n                for value in item[key]:\n                    orig = {k: v for k, v in item.items() if k != key}\n                    d = {**value, **orig}\n                    yield d\n\n        return LazyLines(g=new_gen())\n\n    def explode(self, key: str) -&gt; LazyLines:\n        \"\"\"\n        Explodes a key, effectively un-nesting it.\n\n        Arguments:\n            key: the key to explode\n\n        **Usage**:\n\n        ```python\n        from lazylines import LazyLines\n\n        data = [{'foo': 'a', 'bar': [1, 2, 3]}]\n\n        expected = [\n            {'foo': 'a', 'bar': 1},\n            {'foo': 'a', 'bar': 2},\n            {'foo': 'a', 'bar': 3},\n        ]\n\n        result = LazyLines(data).explode(\"bar\").collect()\n        assert result == expected\n        ```\n        \"\"\"\n\n        def new_gen():\n            for item in self.g:\n                for value in item[key]:\n                    orig = {k: v for k, v in item.items() if k != key}\n                    d = {**orig, key: value}\n                    yield d\n\n        return LazyLines(g=new_gen())\n\n    def head(self, n=5) -&gt; LazyLines:\n        \"\"\"\n        Make a subset and only return the top `n` items.\n\n        Arguments:\n            n: the number of examples to take\n        \"\"\"\n        if isinstance(self.g, list):\n            return LazyLines(g=(i for i in self.g[:5]))\n\n        def new_gen():\n            for _ in range(n):\n                with contextlib.suppress(StopIteration):\n                    yield next(self.g)\n\n        return LazyLines(g=new_gen())\n\n    def show(self, n: int = 1) -&gt; LazyLines:\n        \"\"\"\n        Give a preview of the first `n` examples.\n\n        Arguments:\n            n: the number of examples to preview\n        \"\"\"\n        stream_orig, stream_copy = it.tee(self.g)\n        for _ in range(n):\n            pprint.pprint(next(stream_copy))\n        return LazyLines(g=stream_orig)\n\n    def map(self, func: Callable) -&gt; LazyLines:\n        \"\"\"\n        Apply a function to each item before yielding it back.\n\n        Arguments:\n            func: the function to call on each item\n        \"\"\"\n\n        def new_gen():\n            for item in self.g:\n                yield func(item)\n\n        return LazyLines(g=new_gen())\n\n    def tee(self, n: int = 2) -&gt; tuple[LazyLines]:\n        \"\"\"\n        Copies the lazylines.\n\n        Arguments:\n            n: how often to `tee` the stream\n\n        Usage:\n\n        ```python\n        from lazylines import LazyLines\n\n        data = [\n            {'accept': True, 'annotator': 'a', 'text': 'foo'},\n            {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n            {'accept': True, 'annotator': 'b', 'text': 'foo'},\n            {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n        ]\n\n        lines1, lines2 = LazyLines(data).tee(n=2)\n        lines1, lines2, lines3 = LazyLines(data).tee(n=3)\n        ```\n        \"\"\"\n        return tuple(LazyLines(g=gen) for gen in it.tee(self.g, n))\n\n    def __iter__(self):\n        return iter(self.g)\n\n    def sort_by(self, *keys: str) -&gt; LazyLines:\n        \"\"\"\n        Sort the items based on a subset of the keys.\n\n        Arguments:\n            keys: the keys to use for sorting\n        \"\"\"\n        return LazyLines(g=sorted(self.g, key=lambda d: tuple([d[c] for c in keys])))\n\n    def rename(self, **kwargs: dict[str, str]) -&gt; LazyLines:\n        \"\"\"\n        Rename a few keys in each item.\n\n        Arguments:\n            kwargs: str/str pairs that resemble the new name and old name of a key\n\n        Usage:\n\n        ```python\n        from lazylines import LazyLines\n\n        data = [\n            {'labeller': 'a', 'text': 'foo'},\n            {'labeller': 'a', 'text': 'foobar'},\n            {'labeller': 'b', 'text': 'foo'},\n            {'labeller': 'b', 'text': 'foobar'}\n        ]\n\n        expected = [\n            {'annotator': 'a', 'text': 'foo'},\n            {'annotator': 'a', 'text': 'foobar'},\n            {'annotator': 'b', 'text': 'foo'},\n            {'annotator': 'b', 'text': 'foobar'}\n        ]\n\n        result = (LazyLines(data).rename(annotator=\"labeller\").collect())\n        assert result == expected\n        ```\n        \"\"\"\n\n        def new_gen():\n            for item in self.g:\n                old = {k: v for k, v in item.items() if k not in kwargs.values()}\n                new = {k: item[v] for k, v in kwargs.items()}\n                yield {**old, **new}\n\n        return LazyLines(g=new_gen())\n\n    def nest_by(self, *keys: str) -&gt; LazyLines:\n        \"\"\"\n        Group by keys and return nested collections.\n\n        The opposite of `.unnest()`\n\n        Arguments:\n            keys: the keys to nest by\n\n        **Usage**:\n\n        ```python\n        from lazylines import LazyLines\n\n        data = [\n            {'accept': True, 'annotator': 'a', 'text': 'foo'},\n            {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n            {'accept': True, 'annotator': 'b', 'text': 'foo'},\n            {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n        ]\n\n        expected = [\n                {'annotator': 'a',\n                 'subset': [{'accept': True, 'text': 'foo'},\n                            {'accept': True, 'text': 'foobar'}]},\n                {'annotator': 'b',\n                 'subset': [{'accept': True, 'text': 'foo'},\n                            {'accept': True, 'text': 'foobar'}]}\n        ]\n\n        result = LazyLines(data).nest_by(\"annotator\")\n        assert result.collect() == expected\n        ```\n        \"\"\"\n        groups = {}\n        for example in self.g:\n            key = tuple(example.get(arg, None) for arg in keys)\n            if key not in groups:\n                groups[key] = []\n            for arg in keys:\n                del example[arg]\n            groups[key].append(example)\n        result = []\n        for key, values in groups.items():\n            result.append({**dict(zip(keys, key)), \"subset\": values})\n        return LazyLines(result)\n\n    def progress(self, desc: str | None = None) -&gt; LazyLines:\n        \"\"\"Adds a progress bar. Meant to be used early.\"\"\"\n        stream_orig, stream_copy = it.tee(self.g)\n        total = sum(1 for _ in stream_copy)\n\n        def new_gen():\n            yield from tqdm.tqdm(stream_orig, total=total, desc=desc)\n\n        return LazyLines(g=new_gen())\n\n    def collect(self) -&gt; LazyLines:\n        \"\"\"\n        Turns the (final) sequence into a list.\n\n        Note that, as a consequence, this will also empty the lazyline object.\n        \"\"\"\n        return list(self.g)\n\n    def write_jsonl(self, path, append: bool = False, append_new_line: bool = True) -&gt; LazyLines:\n        \"\"\"\n        Write everything into a jsonl file.\n\n        Note that, as a consequence, this will also empty the lazyline object.\n        \"\"\"\n        srsly.write_jsonl(path, self.g, append=append, append_new_line=append_new_line)\n\n    def select(self, *keys: str) -&gt; LazyLines:\n        \"\"\"\n        Only select specific keys from each dictionary.\n\n        Arguments:\n            keys: the names of the keys to be kept around\n\n        Usage:\n\n        ```python\n        from lazylines import LazyLines\n\n        data = [\n            {'accept': True, 'annotator': 'a', 'text': 'foo'},\n            {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n            {'accept': True, 'annotator': 'b', 'text': 'foo'},\n            {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n        ]\n\n        expected = [\n            {'annotator': 'a', 'text': 'foo'},\n            {'annotator': 'a', 'text': 'foobar'},\n            {'annotator': 'b', 'text': 'foo'},\n            {'annotator': 'b', 'text': 'foobar'}\n        ]\n\n        result = LazyLines(data).select(\"annotator\", \"text\")\n        assert result.collect() == expected\n        ```\n        \"\"\"\n\n        def new_gen():\n            for ex in self.g:\n                yield {k: v for k, v in ex.items() if k in keys}\n\n        return LazyLines(g=new_gen())\n\n    def drop(self, *args) -&gt; LazyLines:\n        \"\"\"\n        Drop specific keys from each dictionary.\n\n        Arguments:\n            keys: the names of the keys to be kept around\n\n        Usage:\n\n        ```python\n        from lazylines import LazyLines\n\n        data = [\n            {'accept': True, 'annotator': 'a', 'text': 'foo'},\n            {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n            {'accept': True, 'annotator': 'b', 'text': 'foo'},\n            {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n        ]\n\n        expected = [\n            {'annotator': 'a', 'text': 'foo'},\n            {'annotator': 'a', 'text': 'foobar'},\n            {'annotator': 'b', 'text': 'foo'},\n            {'annotator': 'b', 'text': 'foobar'}\n        ]\n\n        result = LazyLines(data).drop(\"accept\")\n        assert result.collect() == expected\n        ```\n        \"\"\"\n\n        def new_gen():\n            for ex in self.g:\n                yield {k: v for k, v in ex.items() if k not in args}\n\n        return LazyLines(g=new_gen())\n\n    def pipe(self, func, *args, **kwargs) -&gt; LazyLines:\n        \"\"\"Call a function over the entire generator.\"\"\"\n        return LazyLines(g=func(self, *args, **kwargs))\n\n    def foreach(self, func, *args, **kwargs) -&gt; LazyLines:\n        \"\"\"Just call a function on each dictionary, but pass the original forward.\"\"\"\n\n        def new_gen():\n            for ex in self.g:\n                func(ex, *args, **kwargs)\n                yield ex\n\n        return LazyLines(g=new_gen())\n\n    def agg(self, *args: Callable):\n        \"\"\"\n        Allows you to aggregate over all the items using special functions\n        that will go over each item exactly once.\n\n        This function hopefully makes some things faster, but for something\n        specialized it's best to just write a custom `.pipe()` function.\n\n        ```python\n        from lazylines import LazyLines\n        from lazylines.functions import calc_mean, count\n\n        examples = [\n            {'foo': 1, 'bar': 2},\n            {'foo': 3, 'bar': 2},\n            {'foo': -1, 'bar': 1},\n        ]\n\n        lines = LazyLines(examples)\n\n        out = lines.agg(calc_mean('foo'), calc_mean('bar'), count())\n        expected = {'mean_foo': 3, 'mean_bar': 5, 'count': 3}\n        assert out == expected\n        ```\n        \"\"\"\n\n        accumulators = {}\n        values = {}\n        for arg in args:\n            name, func = arg\n            accumulators[name] = func\n\n        for ex in self.g:\n            for name, func in accumulators.items():\n                values[name] = func(ex)\n\n        return values\n\n    def validate(self, pydantic_cls) -&gt; LazyLines:\n        \"\"\"\n        Validates each example with a Pydantic class. Then dumps the result back.\n\n        Usage:\n\n        ```python\n        from pydantic import BaseModel, PositiveInt\n        from lazylines import LazyLines\n\n        class Example(BaseModel):\n            id: int\n            positive_int: PositiveInt\n\n        lines = LazyLines(({\"id\": i, \"positive_int\": str(i)} for i in range(1, 10)))\n        collected = lines.validate(Example).collect()\n\n        assert collected[0] == {'id': 1, 'positive_int': 1}\n        assert collected[1] == {'id': 2, 'positive_int': 2}\n        ```\n        \"\"\"\n        new_gen = (pydantic_cls(**ex).model_dump() for ex in self.g)\n        return LazyLines(g=new_gen)\n</code></pre>"},{"location":"api/#lazylines.LazyLines.agg","title":"<code>agg(*args)</code>","text":"<p>Allows you to aggregate over all the items using special functions that will go over each item exactly once.</p> <p>This function hopefully makes some things faster, but for something specialized it's best to just write a custom <code>.pipe()</code> function.</p> <pre><code>from lazylines import LazyLines\nfrom lazylines.functions import calc_mean, count\n\nexamples = [\n    {'foo': 1, 'bar': 2},\n    {'foo': 3, 'bar': 2},\n    {'foo': -1, 'bar': 1},\n]\n\nlines = LazyLines(examples)\n\nout = lines.agg(calc_mean('foo'), calc_mean('bar'), count())\nexpected = {'mean_foo': 3, 'mean_bar': 5, 'count': 3}\nassert out == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def agg(self, *args: Callable):\n    \"\"\"\n    Allows you to aggregate over all the items using special functions\n    that will go over each item exactly once.\n\n    This function hopefully makes some things faster, but for something\n    specialized it's best to just write a custom `.pipe()` function.\n\n    ```python\n    from lazylines import LazyLines\n    from lazylines.functions import calc_mean, count\n\n    examples = [\n        {'foo': 1, 'bar': 2},\n        {'foo': 3, 'bar': 2},\n        {'foo': -1, 'bar': 1},\n    ]\n\n    lines = LazyLines(examples)\n\n    out = lines.agg(calc_mean('foo'), calc_mean('bar'), count())\n    expected = {'mean_foo': 3, 'mean_bar': 5, 'count': 3}\n    assert out == expected\n    ```\n    \"\"\"\n\n    accumulators = {}\n    values = {}\n    for arg in args:\n        name, func = arg\n        accumulators[name] = func\n\n    for ex in self.g:\n        for name, func in accumulators.items():\n            values[name] = func(ex)\n\n    return values\n</code></pre>"},{"location":"api/#lazylines.LazyLines.cache","title":"<code>cache()</code>","text":"<p>Cache the result internally by turning it into a list.</p> <p>It's recommended to store the result into another variable.</p> <pre><code>from lazylines import LazyLines\n\nitems = ({\"a\": i} for i in range(100))\n\n# The output is still a LazyLines object, but the intermediate representation\n# is now a list which might speedup repeated downstream tasks\ncached = (LazyLines(items).cache())\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def cache(self) -&gt; LazyLines:\n    \"\"\"\n    Cache the result internally by turning it into a list.\n\n    It's recommended to store the result into another variable.\n\n    ```python\n    from lazylines import LazyLines\n\n    items = ({\"a\": i} for i in range(100))\n\n    # The output is still a LazyLines object, but the intermediate representation\n    # is now a list which might speedup repeated downstream tasks\n    cached = (LazyLines(items).cache())\n    ```\n    \"\"\"\n    return LazyLines(g=list(self.g))\n</code></pre>"},{"location":"api/#lazylines.LazyLines.collect","title":"<code>collect()</code>","text":"<p>Turns the (final) sequence into a list.</p> <p>Note that, as a consequence, this will also empty the lazyline object.</p> Source code in <code>lazylines/__init__.py</code> <pre><code>def collect(self) -&gt; LazyLines:\n    \"\"\"\n    Turns the (final) sequence into a list.\n\n    Note that, as a consequence, this will also empty the lazyline object.\n    \"\"\"\n    return list(self.g)\n</code></pre>"},{"location":"api/#lazylines.LazyLines.drop","title":"<code>drop(*args)</code>","text":"<p>Drop specific keys from each dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <p>the names of the keys to be kept around</p> required <p>Usage:</p> <pre><code>from lazylines import LazyLines\n\ndata = [\n    {'accept': True, 'annotator': 'a', 'text': 'foo'},\n    {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n    {'accept': True, 'annotator': 'b', 'text': 'foo'},\n    {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n]\n\nexpected = [\n    {'annotator': 'a', 'text': 'foo'},\n    {'annotator': 'a', 'text': 'foobar'},\n    {'annotator': 'b', 'text': 'foo'},\n    {'annotator': 'b', 'text': 'foobar'}\n]\n\nresult = LazyLines(data).drop(\"accept\")\nassert result.collect() == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def drop(self, *args) -&gt; LazyLines:\n    \"\"\"\n    Drop specific keys from each dictionary.\n\n    Arguments:\n        keys: the names of the keys to be kept around\n\n    Usage:\n\n    ```python\n    from lazylines import LazyLines\n\n    data = [\n        {'accept': True, 'annotator': 'a', 'text': 'foo'},\n        {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n        {'accept': True, 'annotator': 'b', 'text': 'foo'},\n        {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n    ]\n\n    expected = [\n        {'annotator': 'a', 'text': 'foo'},\n        {'annotator': 'a', 'text': 'foobar'},\n        {'annotator': 'b', 'text': 'foo'},\n        {'annotator': 'b', 'text': 'foobar'}\n    ]\n\n    result = LazyLines(data).drop(\"accept\")\n    assert result.collect() == expected\n    ```\n    \"\"\"\n\n    def new_gen():\n        for ex in self.g:\n            yield {k: v for k, v in ex.items() if k not in args}\n\n    return LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.explode","title":"<code>explode(key)</code>","text":"<p>Explodes a key, effectively un-nesting it.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the key to explode</p> required <p>Usage:</p> <pre><code>from lazylines import LazyLines\n\ndata = [{'foo': 'a', 'bar': [1, 2, 3]}]\n\nexpected = [\n    {'foo': 'a', 'bar': 1},\n    {'foo': 'a', 'bar': 2},\n    {'foo': 'a', 'bar': 3},\n]\n\nresult = LazyLines(data).explode(\"bar\").collect()\nassert result == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def explode(self, key: str) -&gt; LazyLines:\n    \"\"\"\n    Explodes a key, effectively un-nesting it.\n\n    Arguments:\n        key: the key to explode\n\n    **Usage**:\n\n    ```python\n    from lazylines import LazyLines\n\n    data = [{'foo': 'a', 'bar': [1, 2, 3]}]\n\n    expected = [\n        {'foo': 'a', 'bar': 1},\n        {'foo': 'a', 'bar': 2},\n        {'foo': 'a', 'bar': 3},\n    ]\n\n    result = LazyLines(data).explode(\"bar\").collect()\n    assert result == expected\n    ```\n    \"\"\"\n\n    def new_gen():\n        for item in self.g:\n            for value in item[key]:\n                orig = {k: v for k, v in item.items() if k != key}\n                d = {**orig, key: value}\n                yield d\n\n    return LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.foreach","title":"<code>foreach(func, *args, **kwargs)</code>","text":"<p>Just call a function on each dictionary, but pass the original forward.</p> Source code in <code>lazylines/__init__.py</code> <pre><code>def foreach(self, func, *args, **kwargs) -&gt; LazyLines:\n    \"\"\"Just call a function on each dictionary, but pass the original forward.\"\"\"\n\n    def new_gen():\n        for ex in self.g:\n            func(ex, *args, **kwargs)\n            yield ex\n\n    return LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.head","title":"<code>head(n=5)</code>","text":"<p>Make a subset and only return the top <code>n</code> items.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <p>the number of examples to take</p> <code>5</code> Source code in <code>lazylines/__init__.py</code> <pre><code>def head(self, n=5) -&gt; LazyLines:\n    \"\"\"\n    Make a subset and only return the top `n` items.\n\n    Arguments:\n        n: the number of examples to take\n    \"\"\"\n    if isinstance(self.g, list):\n        return LazyLines(g=(i for i in self.g[:5]))\n\n    def new_gen():\n        for _ in range(n):\n            with contextlib.suppress(StopIteration):\n                yield next(self.g)\n\n    return LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.keep","title":"<code>keep(*args)</code>","text":"<p>Only keep a subset of the items in the generator based on lambda.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Callable</code> <p>functions that can be used to filter the data, if it outputs <code>True</code> it will be kept around</p> <code>()</code> <p>Usage:</p> <pre><code>from lazylines import LazyLines\n\nitems = [{\"a\": 2}, {\"a\": 3}]\nresults = (LazyLines(items).keep(lambda d: d[\"a\"] % 2 == 0))\nexpected = [{\"a\": 2}]\nassert results.collect() == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def keep(self, *args: Callable) -&gt; LazyLines:\n    \"\"\"\n    Only keep a subset of the items in the generator based on lambda.\n\n    Arguments:\n        args: functions that can be used to filter the data, if it outputs `True` it will be kept around\n\n    **Usage**:\n\n    ```python\n    from lazylines import LazyLines\n\n    items = [{\"a\": 2}, {\"a\": 3}]\n    results = (LazyLines(items).keep(lambda d: d[\"a\"] % 2 == 0))\n    expected = [{\"a\": 2}]\n    assert results.collect() == expected\n    ```\n    \"\"\"\n\n    def new_gen():\n        for item in self.g:\n            allowed = True\n            for func in args:\n                if not func(item):\n                    allowed = False\n            if allowed:\n                yield item\n\n    return LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.map","title":"<code>map(func)</code>","text":"<p>Apply a function to each item before yielding it back.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>the function to call on each item</p> required Source code in <code>lazylines/__init__.py</code> <pre><code>def map(self, func: Callable) -&gt; LazyLines:\n    \"\"\"\n    Apply a function to each item before yielding it back.\n\n    Arguments:\n        func: the function to call on each item\n    \"\"\"\n\n    def new_gen():\n        for item in self.g:\n            yield func(item)\n\n    return LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.mutate","title":"<code>mutate(**kwargs)</code>","text":"<p>Adds/overwrites keys in the dictionary based on lambda.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict[str, Callable]</code> <p>str/callable pairs that represent keys and a function to calculate it's value</p> <code>{}</code> <p>Usage:</p> <pre><code>from lazylines import LazyLines\n\nitems = [{\"a\": 2}, {\"a\": 3}]\nresults = (LazyLines(items).mutate(b=lambda d: d[\"a\"] * 2))\nexpected = [{\"a\": 2, \"b\": 4}, {\"a\": 3, \"b\": 6}]\nassert results.collect() == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def mutate(self, **kwargs: dict[str, Callable]) -&gt; LazyLines:\n    \"\"\"\n    Adds/overwrites keys in the dictionary based on lambda.\n\n    Arguments:\n        kwargs: str/callable pairs that represent keys and a function to calculate it's value\n\n    **Usage**:\n\n    ```python\n    from lazylines import LazyLines\n\n    items = [{\"a\": 2}, {\"a\": 3}]\n    results = (LazyLines(items).mutate(b=lambda d: d[\"a\"] * 2))\n    expected = [{\"a\": 2, \"b\": 4}, {\"a\": 3, \"b\": 6}]\n    assert results.collect() == expected\n    ```\n    \"\"\"\n\n    def new_gen():\n        for item in self.g:\n            for k, v in kwargs.items():\n                item[k] = v(item)\n            yield item\n\n    return LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.nest_by","title":"<code>nest_by(*keys)</code>","text":"<p>Group by keys and return nested collections.</p> <p>The opposite of <code>.unnest()</code></p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>str</code> <p>the keys to nest by</p> <code>()</code> <p>Usage:</p> <pre><code>from lazylines import LazyLines\n\ndata = [\n    {'accept': True, 'annotator': 'a', 'text': 'foo'},\n    {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n    {'accept': True, 'annotator': 'b', 'text': 'foo'},\n    {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n]\n\nexpected = [\n        {'annotator': 'a',\n         'subset': [{'accept': True, 'text': 'foo'},\n                    {'accept': True, 'text': 'foobar'}]},\n        {'annotator': 'b',\n         'subset': [{'accept': True, 'text': 'foo'},\n                    {'accept': True, 'text': 'foobar'}]}\n]\n\nresult = LazyLines(data).nest_by(\"annotator\")\nassert result.collect() == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def nest_by(self, *keys: str) -&gt; LazyLines:\n    \"\"\"\n    Group by keys and return nested collections.\n\n    The opposite of `.unnest()`\n\n    Arguments:\n        keys: the keys to nest by\n\n    **Usage**:\n\n    ```python\n    from lazylines import LazyLines\n\n    data = [\n        {'accept': True, 'annotator': 'a', 'text': 'foo'},\n        {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n        {'accept': True, 'annotator': 'b', 'text': 'foo'},\n        {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n    ]\n\n    expected = [\n            {'annotator': 'a',\n             'subset': [{'accept': True, 'text': 'foo'},\n                        {'accept': True, 'text': 'foobar'}]},\n            {'annotator': 'b',\n             'subset': [{'accept': True, 'text': 'foo'},\n                        {'accept': True, 'text': 'foobar'}]}\n    ]\n\n    result = LazyLines(data).nest_by(\"annotator\")\n    assert result.collect() == expected\n    ```\n    \"\"\"\n    groups = {}\n    for example in self.g:\n        key = tuple(example.get(arg, None) for arg in keys)\n        if key not in groups:\n            groups[key] = []\n        for arg in keys:\n            del example[arg]\n        groups[key].append(example)\n    result = []\n    for key, values in groups.items():\n        result.append({**dict(zip(keys, key)), \"subset\": values})\n    return LazyLines(result)\n</code></pre>"},{"location":"api/#lazylines.LazyLines.pipe","title":"<code>pipe(func, *args, **kwargs)</code>","text":"<p>Call a function over the entire generator.</p> Source code in <code>lazylines/__init__.py</code> <pre><code>def pipe(self, func, *args, **kwargs) -&gt; LazyLines:\n    \"\"\"Call a function over the entire generator.\"\"\"\n    return LazyLines(g=func(self, *args, **kwargs))\n</code></pre>"},{"location":"api/#lazylines.LazyLines.progress","title":"<code>progress(desc=None)</code>","text":"<p>Adds a progress bar. Meant to be used early.</p> Source code in <code>lazylines/__init__.py</code> <pre><code>def progress(self, desc: str | None = None) -&gt; LazyLines:\n    \"\"\"Adds a progress bar. Meant to be used early.\"\"\"\n    stream_orig, stream_copy = it.tee(self.g)\n    total = sum(1 for _ in stream_copy)\n\n    def new_gen():\n        yield from tqdm.tqdm(stream_orig, total=total, desc=desc)\n\n    return LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.rename","title":"<code>rename(**kwargs)</code>","text":"<p>Rename a few keys in each item.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict[str, str]</code> <p>str/str pairs that resemble the new name and old name of a key</p> <code>{}</code> <p>Usage:</p> <pre><code>from lazylines import LazyLines\n\ndata = [\n    {'labeller': 'a', 'text': 'foo'},\n    {'labeller': 'a', 'text': 'foobar'},\n    {'labeller': 'b', 'text': 'foo'},\n    {'labeller': 'b', 'text': 'foobar'}\n]\n\nexpected = [\n    {'annotator': 'a', 'text': 'foo'},\n    {'annotator': 'a', 'text': 'foobar'},\n    {'annotator': 'b', 'text': 'foo'},\n    {'annotator': 'b', 'text': 'foobar'}\n]\n\nresult = (LazyLines(data).rename(annotator=\"labeller\").collect())\nassert result == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def rename(self, **kwargs: dict[str, str]) -&gt; LazyLines:\n    \"\"\"\n    Rename a few keys in each item.\n\n    Arguments:\n        kwargs: str/str pairs that resemble the new name and old name of a key\n\n    Usage:\n\n    ```python\n    from lazylines import LazyLines\n\n    data = [\n        {'labeller': 'a', 'text': 'foo'},\n        {'labeller': 'a', 'text': 'foobar'},\n        {'labeller': 'b', 'text': 'foo'},\n        {'labeller': 'b', 'text': 'foobar'}\n    ]\n\n    expected = [\n        {'annotator': 'a', 'text': 'foo'},\n        {'annotator': 'a', 'text': 'foobar'},\n        {'annotator': 'b', 'text': 'foo'},\n        {'annotator': 'b', 'text': 'foobar'}\n    ]\n\n    result = (LazyLines(data).rename(annotator=\"labeller\").collect())\n    assert result == expected\n    ```\n    \"\"\"\n\n    def new_gen():\n        for item in self.g:\n            old = {k: v for k, v in item.items() if k not in kwargs.values()}\n            new = {k: item[v] for k, v in kwargs.items()}\n            yield {**old, **new}\n\n    return LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.select","title":"<code>select(*keys)</code>","text":"<p>Only select specific keys from each dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>str</code> <p>the names of the keys to be kept around</p> <code>()</code> <p>Usage:</p> <pre><code>from lazylines import LazyLines\n\ndata = [\n    {'accept': True, 'annotator': 'a', 'text': 'foo'},\n    {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n    {'accept': True, 'annotator': 'b', 'text': 'foo'},\n    {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n]\n\nexpected = [\n    {'annotator': 'a', 'text': 'foo'},\n    {'annotator': 'a', 'text': 'foobar'},\n    {'annotator': 'b', 'text': 'foo'},\n    {'annotator': 'b', 'text': 'foobar'}\n]\n\nresult = LazyLines(data).select(\"annotator\", \"text\")\nassert result.collect() == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def select(self, *keys: str) -&gt; LazyLines:\n    \"\"\"\n    Only select specific keys from each dictionary.\n\n    Arguments:\n        keys: the names of the keys to be kept around\n\n    Usage:\n\n    ```python\n    from lazylines import LazyLines\n\n    data = [\n        {'accept': True, 'annotator': 'a', 'text': 'foo'},\n        {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n        {'accept': True, 'annotator': 'b', 'text': 'foo'},\n        {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n    ]\n\n    expected = [\n        {'annotator': 'a', 'text': 'foo'},\n        {'annotator': 'a', 'text': 'foobar'},\n        {'annotator': 'b', 'text': 'foo'},\n        {'annotator': 'b', 'text': 'foobar'}\n    ]\n\n    result = LazyLines(data).select(\"annotator\", \"text\")\n    assert result.collect() == expected\n    ```\n    \"\"\"\n\n    def new_gen():\n        for ex in self.g:\n            yield {k: v for k, v in ex.items() if k in keys}\n\n    return LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.show","title":"<code>show(n=1)</code>","text":"<p>Give a preview of the first <code>n</code> examples.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>the number of examples to preview</p> <code>1</code> Source code in <code>lazylines/__init__.py</code> <pre><code>def show(self, n: int = 1) -&gt; LazyLines:\n    \"\"\"\n    Give a preview of the first `n` examples.\n\n    Arguments:\n        n: the number of examples to preview\n    \"\"\"\n    stream_orig, stream_copy = it.tee(self.g)\n    for _ in range(n):\n        pprint.pprint(next(stream_copy))\n    return LazyLines(g=stream_orig)\n</code></pre>"},{"location":"api/#lazylines.LazyLines.sort_by","title":"<code>sort_by(*keys)</code>","text":"<p>Sort the items based on a subset of the keys.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>str</code> <p>the keys to use for sorting</p> <code>()</code> Source code in <code>lazylines/__init__.py</code> <pre><code>def sort_by(self, *keys: str) -&gt; LazyLines:\n    \"\"\"\n    Sort the items based on a subset of the keys.\n\n    Arguments:\n        keys: the keys to use for sorting\n    \"\"\"\n    return LazyLines(g=sorted(self.g, key=lambda d: tuple([d[c] for c in keys])))\n</code></pre>"},{"location":"api/#lazylines.LazyLines.tee","title":"<code>tee(n=2)</code>","text":"<p>Copies the lazylines.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>how often to <code>tee</code> the stream</p> <code>2</code> <p>Usage:</p> <pre><code>from lazylines import LazyLines\n\ndata = [\n    {'accept': True, 'annotator': 'a', 'text': 'foo'},\n    {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n    {'accept': True, 'annotator': 'b', 'text': 'foo'},\n    {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n]\n\nlines1, lines2 = LazyLines(data).tee(n=2)\nlines1, lines2, lines3 = LazyLines(data).tee(n=3)\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def tee(self, n: int = 2) -&gt; tuple[LazyLines]:\n    \"\"\"\n    Copies the lazylines.\n\n    Arguments:\n        n: how often to `tee` the stream\n\n    Usage:\n\n    ```python\n    from lazylines import LazyLines\n\n    data = [\n        {'accept': True, 'annotator': 'a', 'text': 'foo'},\n        {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n        {'accept': True, 'annotator': 'b', 'text': 'foo'},\n        {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n    ]\n\n    lines1, lines2 = LazyLines(data).tee(n=2)\n    lines1, lines2, lines3 = LazyLines(data).tee(n=3)\n    ```\n    \"\"\"\n    return tuple(LazyLines(g=gen) for gen in it.tee(self.g, n))\n</code></pre>"},{"location":"api/#lazylines.LazyLines.unnest","title":"<code>unnest(key='subset')</code>","text":"<p>Un-nests a list of dictionaries in a key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the key to un-nest</p> <code>'subset'</code> <p>Usage:</p> <pre><code>from lazylines import LazyLines\n\ndata = [{'annotator': 'a',\n         'subset': [{'accept': True, 'text': 'foo'},\n                    {'accept': True, 'text': 'foobar'}]},\n        {'annotator': 'b',\n         'subset': [{'accept': True, 'text': 'foo'},\n                    {'accept': True, 'text': 'foobar'}]}]\n\nexpected = [\n    {'accept': True, 'annotator': 'a', 'text': 'foo'},\n    {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n    {'accept': True, 'annotator': 'b', 'text': 'foo'},\n    {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n]\n\nresult = LazyLines(data).unnest(\"subset\").collect()\nassert result == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def unnest(self, key: str = \"subset\") -&gt; LazyLines:\n    \"\"\"\n    Un-nests a list of dictionaries in a key\n\n    Arguments:\n        key: the key to un-nest\n\n    **Usage**:\n\n    ```python\n    from lazylines import LazyLines\n\n    data = [{'annotator': 'a',\n             'subset': [{'accept': True, 'text': 'foo'},\n                        {'accept': True, 'text': 'foobar'}]},\n            {'annotator': 'b',\n             'subset': [{'accept': True, 'text': 'foo'},\n                        {'accept': True, 'text': 'foobar'}]}]\n\n    expected = [\n        {'accept': True, 'annotator': 'a', 'text': 'foo'},\n        {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n        {'accept': True, 'annotator': 'b', 'text': 'foo'},\n        {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n    ]\n\n    result = LazyLines(data).unnest(\"subset\").collect()\n    assert result == expected\n    ```\n    \"\"\"\n\n    def new_gen():\n        for item in self.g:\n            for value in item[key]:\n                orig = {k: v for k, v in item.items() if k != key}\n                d = {**value, **orig}\n                yield d\n\n    return LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.validate","title":"<code>validate(pydantic_cls)</code>","text":"<p>Validates each example with a Pydantic class. Then dumps the result back.</p> <p>Usage:</p> <pre><code>from pydantic import BaseModel, PositiveInt\nfrom lazylines import LazyLines\n\nclass Example(BaseModel):\n    id: int\n    positive_int: PositiveInt\n\nlines = LazyLines(({\"id\": i, \"positive_int\": str(i)} for i in range(1, 10)))\ncollected = lines.validate(Example).collect()\n\nassert collected[0] == {'id': 1, 'positive_int': 1}\nassert collected[1] == {'id': 2, 'positive_int': 2}\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def validate(self, pydantic_cls) -&gt; LazyLines:\n    \"\"\"\n    Validates each example with a Pydantic class. Then dumps the result back.\n\n    Usage:\n\n    ```python\n    from pydantic import BaseModel, PositiveInt\n    from lazylines import LazyLines\n\n    class Example(BaseModel):\n        id: int\n        positive_int: PositiveInt\n\n    lines = LazyLines(({\"id\": i, \"positive_int\": str(i)} for i in range(1, 10)))\n    collected = lines.validate(Example).collect()\n\n    assert collected[0] == {'id': 1, 'positive_int': 1}\n    assert collected[1] == {'id': 2, 'positive_int': 2}\n    ```\n    \"\"\"\n    new_gen = (pydantic_cls(**ex).model_dump() for ex in self.g)\n    return LazyLines(g=new_gen)\n</code></pre>"},{"location":"api/#lazylines.LazyLines.write_jsonl","title":"<code>write_jsonl(path, append=False, append_new_line=True)</code>","text":"<p>Write everything into a jsonl file.</p> <p>Note that, as a consequence, this will also empty the lazyline object.</p> Source code in <code>lazylines/__init__.py</code> <pre><code>def write_jsonl(self, path, append: bool = False, append_new_line: bool = True) -&gt; LazyLines:\n    \"\"\"\n    Write everything into a jsonl file.\n\n    Note that, as a consequence, this will also empty the lazyline object.\n    \"\"\"\n    srsly.write_jsonl(path, self.g, append=append, append_new_line=append_new_line)\n</code></pre>"}]}