{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>Lazylines is a small Python library that makes it easier to work with lists of dictionaries as well as JSONL files. It was originally designed to help handle some boilerplate for some of my custom Prodigy recipes.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>To give a demo of what the base useage might look like, let's download a .jsonl file. </p> <pre><code>wget https://calmcode.io/datasets/pokemon.jsonl\n</code></pre> <p>This file has data that looks like this: </p> <pre><code>{\"attack\": 49, \"hp\": 45, \"name\": \"Bulbasaur\", \"total\": 318, \"type\": [\"Grass\", \"Poison\"]}\n{\"attack\": 62, \"hp\": 60, \"name\": \"Ivysaur\", \"total\": 405, \"type\": [\"Grass\", \"Poison\"]}\n</code></pre> <pre><code>from lazylines import read_jsonl\n(\nread_jsonl(\"tests/pokemon.jsonl\")\n.unnest(\"type\")\n.nest_by(\"type\")\n.mutate(count=lambda d: len(d['subset']))\n.drop(\"subset\")\n.collect()\n)\n</code></pre> <p>Let's go through everything happening line-by-line. </p> <ol> <li>First we read the file with <code>read_jsonl</code>. Internally, it's stored as a generator, so no data is actually being read just yet. </li> <li>Next, we unnest the list in the <code>\"type\"</code> key. This turns an item with a nested example into two examples each containing one of the nested items.  </li> <li>Next, we nest by the type again. This allows us to have an item for each <code>\"type\"</code> together with a <code>\"subset\"</code> key that contains all relevant examples that belong to the <code>\"type\"</code>. </li> <li>Next, we add a key called <code>\"count\"</code> by calculating the length of the subset. </li> <li>Next, we drop the <code>\"subset\"</code> key. </li> <li>Finally, we <code>collect()</code> the data. All the previous steps were \"lazy\", only when we call <code>collect()</code> do we actually perform the operations in the chain. </li> </ol> <p>This is what the output looks like. </p> <pre><code>[{'type': 'Grass', 'count': 95},\n{'type': 'Poison', 'count': 62},\n{'type': 'Fire', 'count': 64},\n{'type': 'Flying', 'count': 101},\n{'type': 'Dragon', 'count': 50},\n{'type': 'Water', 'count': 126},\n{'type': 'Bug', 'count': 72},\n{'type': 'Normal', 'count': 102},\n{'type': 'Electric', 'count': 50},\n{'type': 'Ground', 'count': 67},\n{'type': 'Fairy', 'count': 40},\n{'type': 'Fighting', 'count': 53},\n{'type': 'Psychic', 'count': 90},\n{'type': 'Rock', 'count': 58},\n{'type': 'Steel', 'count': 49},\n{'type': 'Ice', 'count': 38},\n{'type': 'Ghost', 'count': 46},\n{'type': 'Dark', 'count': 51}]\n</code></pre> <p>There's a lot that you can do just by nesting and unnesting and this library tries to make it easy to perform common data wrangling tasks without having to resort to heavy dependencies.</p>"},{"location":"#fun-features","title":"Fun Features","text":"<p>There are a few fun features to mention out loud. </p>"},{"location":"#progress-bars","title":"Progress bars","text":"<p>If you have long running tasks you can keep track of the progress via the <code>.progress()</code> method. </p> <pre><code>import time \nfrom lazylines import read_jsonl\n(\nread_jsonl(\"tests/pokemon.jsonl\")\n.progress()\n.foreach(lambda d: time.sleep(0.02))\n.collect()\n)\n</code></pre> <p>The <code>foreach</code> method runs a function for each item and then returns the original item. The <code>progress</code> method adds the progress bar. </p>"},{"location":"#intermediate-results","title":"Intermediate results","text":"<p>It can help to \"see\" what is happening in each step in a pipeline.  For these use-cases you can use the <code>.show()</code> method. </p> <pre><code>from lazylines import read_jsonl\n(\nread_jsonl(\"tests/pokemon.jsonl\")\n.show(2)\n.unnest(\"type\")\n.show(2)\n)\n</code></pre> <p>The first call to <code>.show(2)</code> will render: </p> <pre><code>{'attack': 49,\n'hp': 45,\n'name': 'Bulbasaur',\n'total': 318,\n'type': ['Grass', 'Poison']}\n{'attack': 62,\n'hp': 60,\n'name': 'Ivysaur',\n'total': 405,\n'type': ['Grass', 'Poison']}\n</code></pre> <p>The second call to <code>.show(2)</code> will render: </p> <pre><code>{'attack': 49, 'hp': 45, 'name': 'Bulbasaur', 'total': 318, 'type': 'Grass'}\n{'attack': 49, 'hp': 45, 'name': 'Bulbasaur', 'total': 318, 'type': 'Poison'}\n</code></pre>"},{"location":"#learn-more","title":"Learn More","text":"<p>To learn more, check the API guide. </p>"},{"location":"api/","title":"API","text":""},{"location":"api/#lazylines.read_jsonl","title":"<code>lazylines.read_jsonl(path)</code>","text":"<p>Read .jsonl file and turn it into a LazyLines object.</p> Source code in <code>lazylines/__init__.py</code> <pre><code>def read_jsonl(path: Union[str, Path]) -&gt; LazyLines:\n\"\"\"Read .jsonl file and turn it into a LazyLines object.\"\"\"\nreturn LazyLines(srsly.read_jsonl(path))\n</code></pre>"},{"location":"api/#lazylines.LazyLines","title":"<code>lazylines.LazyLines</code>","text":"<p>An object that can wrangle iterables of dictionaries (similar to JSONL).</p> <pre><code>from lazylines import LazyLines\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>class LazyLines:\n\"\"\"\n    An object that can wrangle iterables of dictionaries (similar to JSONL).\n    ```python\n    from lazylines import LazyLines\n    ```\n    \"\"\"\ndef __init__(self, g):\nself.g = g\nself.groups = set()\ndef cache(self) -&gt; LazyLines:\n\"\"\"\n        Cache the result internally by turning it into a list.\n        It's recommended to store the result into another variable.\n        ```python\n        from lazylines import LazyLines\n        items = ({\"a\": i} for i in range(100))\n        # The intermediate representation is now a list.\n        cached = (LazyLines(items).cache())\n        ```\n        \"\"\"\nreturn LazyLines(g=list(self.g))\ndef mutate(self, **kwargs: Dict[str, Callable]) -&gt; LazyLines:\n\"\"\"\n        Adds/overwrites keys in the dictionary based on lambda.\n        Arguments:\n            kwargs: str/callable pairs that represent keys and a function to calculate it's value\n        **Usage**:\n        ```python\n        from lazylines import LazyLines\n        items = [{\"a\": 2}, {\"a\": 3}]\n        results = (LazyLines(items).mutate(b=lambda d: d[\"a\"] * 2))\n        expected = [{\"a\": 2, \"b\": 4}, {\"a\": 3, \"b\": 6}]\n        assert results.collect() == expected\n        ```\n        \"\"\"\ndef new_gen():\nfor item in self.g:\nfor k, v in kwargs.items():\nitem[k] = v(item)\nyield item\nreturn LazyLines(g=new_gen())\ndef keep(self, *args: Callable) -&gt; LazyLines:\n\"\"\"\n        Only keep a subset of the items in the generator based on lambda.\n        Arguments:\n            args: functions that can be used to filter the data, if it outputs `True` it will be kept around\n        **Usage**:\n        ```python\n        from lazylines import LazyLines\n        items = [{\"a\": 2}, {\"a\": 3}]\n        results = (LazyLines(items).keep(lambda d: d[\"a\"] % 2 == 0))\n        expected = [{\"a\": 2}]\n        assert results.collect() == expected\n        ```\n        \"\"\"\ndef new_gen():\nfor item in self.g:\nfor func in args:\nif func(item):\nyield item\nreturn LazyLines(g=new_gen())\ndef unnest(self, key: str) -&gt; LazyLines:\n\"\"\"\n        Explodes a key, effectively un-nesting it.\n        Arguments:\n            key: the key to un-nest\n        **Usage**:\n        ```python\n        from lazylines import LazyLines\n        data = [{'annotator': 'a',\n                 'subset': [{'accept': True, 'text': 'foo'},\n                            {'accept': True, 'text': 'foobar'}]},\n                {'annotator': 'b',\n                 'subset': [{'accept': True, 'text': 'foo'},\n                            {'accept': True, 'text': 'foobar'}]}]\n        expected = [\n            {'accept': True, 'annotator': 'a', 'text': 'foo'},\n            {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n            {'accept': True, 'annotator': 'b', 'text': 'foo'},\n            {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n        ]\n        result = LazyLines(data).unnest(\"subset\")\n        assert result.collect() == expected\n        ```\n        \"\"\"\ndef new_gen():\nfor item in self.g:\nfor value in item[key]:\norig = {k: v for k, v in item.items() if k != key}\nd = {**{key: value}, **orig}\nyield d\nreturn LazyLines(g=new_gen())\ndef head(self, n=5) -&gt; LazyLines:\n\"\"\"\n        Make a subset and only return the top `n` items.\n        Arguments:\n            n: the number of examples to take\n        \"\"\"\nif isinstance(self.g, list):\nreturn LazyLines(g=(i for i in self.g[:5]))\ndef new_gen():\nfor _ in range(n):\nyield next(self.g)\nreturn LazyLines(g=new_gen())\ndef show(self, n: int=5) -&gt; LazyLines:\n\"\"\"\n        Give a preview of the first `n` examples. \n        Arguments:\n            n: the number of examples to preview\n        \"\"\"\nstream_orig, stream_copy = it.tee(self.g)\nfor _ in range(n):\npprint.pprint(next(stream_copy))\nreturn LazyLines(g=stream_orig)\ndef map(self, func: Callable) -&gt; LazyLines:\n\"\"\"\n        Apply a function to each item before yielding it back.\n        Arguments:\n            func: the function to call on each item\n        \"\"\"\ndef new_gen():\nfor item in self.g:\nyield func(item)\nreturn LazyLines(g=new_gen())\ndef tee(self, n:int=2) -&gt; Tuple[LazyLines]:\n\"\"\"\n        Copies the lazylines.\n        Arguments:\n            n: how often to `tee` the stream\n        Usage:\n        ```python\n        from lazylines import LazyLines\n        data = [\n            {'accept': True, 'annotator': 'a', 'text': 'foo'},\n            {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n            {'accept': True, 'annotator': 'b', 'text': 'foo'},\n            {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n        ]\n        lines1, lines2 = LazyLines(data).tee(n=2)\n        lines1, lines2, lines3 = LazyLines(data).tee(n=3)\n        ```\n        \"\"\"\nreturn tuple(LazyLines(g=gen) for gen in it.tee(self.g, n))\ndef __iter__(self):\nreturn self.g\ndef sort_by(self, *keys: str) -&gt; LazyLines:\n\"\"\"\n        Sort the items based on a subset of the keys.\n        Arguments:\n            keys: the keys to use for sorting\n        \"\"\"\nreturn LazyLines(g=sorted(self.g, key=lambda d: tuple([d[c] for c in keys])))\ndef rename(self, **kwargs: Dict[str, str]) -&gt; LazyLines:\n\"\"\"\n        Rename a few keys in each item.\n        Arguments:\n            kwargs: str/str pairs that resemble the new name and old name of a key\n        Usage:\n        ```python\n        from lazylines import LazyLines\n        data = [\n            {'labeller': 'a', 'text': 'foo'},\n            {'labeller': 'a', 'text': 'foobar'},\n            {'labeller': 'b', 'text': 'foo'},\n            {'labeller': 'b', 'text': 'foobar'}\n        ]\n        expected = [\n            {'annotator': 'a', 'text': 'foo'},\n            {'annotator': 'a', 'text': 'foobar'},\n            {'annotator': 'b', 'text': 'foo'},\n            {'annotator': 'b', 'text': 'foobar'}\n        ]\n        result = (LazyLines(data).rename(annotator=\"labeller\").collect())\n        assert result == expected\n        ```\n        \"\"\"\ndef new_gen():\nfor item in self.g:\nnew_items = {k: item[v] for k, v in kwargs.items()}\nyield {**item, **new_items}\nreturn LazyLines(g=new_gen())\ndef nest_by(self, *keys: str) -&gt; LazyLines:\n\"\"\"\n        Group by keys and return nested collections.\n        The opposite of `.unnest()`\n        Arguments:\n            keys: the keys to nest by\n        **Usage**:\n        ```python\n        from lazylines import LazyLines\n        data = [\n            {'accept': True, 'annotator': 'a', 'text': 'foo'},\n            {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n            {'accept': True, 'annotator': 'b', 'text': 'foo'},\n            {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n        ]\n        expected = [\n                {'annotator': 'a',\n                 'subset': [{'accept': True, 'text': 'foo'},\n                            {'accept': True, 'text': 'foobar'}]},\n                {'annotator': 'b',\n                 'subset': [{'accept': True, 'text': 'foo'},\n                            {'accept': True, 'text': 'foobar'}]}\n        ]\n        result = LazyLines(data).nest_by(\"annotator\")\n        assert result.collect() == expected\n        ```\n        \"\"\"\ngroups = {}\nfor example in self.g:\nkey = tuple(example.get(arg, None) for arg in args)\nif key not in groups:\ngroups[key] = []\nfor arg in args:\ndel example[arg]\ngroups[key].append(example)\nresult = []\nfor key, values in groups.items():\nresult.append({**{k: v for k, v in zip(args, key)}, \"subset\": values})\nreturn LazyLines(result)\ndef progress(self) -&gt; LazyLines:\n\"\"\"\n        Adds a progress bar. Meant to be used early.\n        Will also run through the entire stream once to calculate the stream size.\n        \"\"\"\nstream_orig, stream_copy = it.tee(self.g)\ntotal = sum(1 for _ in stream_copy)\nreturn LazyLines(g=tqdm.tqdm(stream_orig, total=total))\ndef collect(self) -&gt; LazyLines:\n\"\"\"\n        Turns the (final) sequence into a list.\n        Note that, as a consequence, this will also empty the lazyline object.\n        \"\"\"\nreturn [ex for ex in self.g]\ndef write_jsonl(\nself, path, append: bool = False, append_new_line: bool = True\n) -&gt; LazyLines:\n\"\"\"\n        Write everything into a jsonl file.\n        Note that, as a consequence, this will also empty the lazyline object.\n        \"\"\"\nsrsly.write_jsonl(path, self.g, append=append, append_new_line=append_new_line)\ndef select(self, *keys: str) -&gt; LazyLines:\n\"\"\"\n        Only select specific keys from each dictionary.\n        Arguments:\n            keys: the names of the keys to be kept around\n        Usage:\n        ```python\n        from lazylines import LazyLines\n        data = [\n            {'accept': True, 'annotator': 'a', 'text': 'foo'},\n            {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n            {'accept': True, 'annotator': 'b', 'text': 'foo'},\n            {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n        ]\n        expected = [\n            {'annotator': 'a', 'text': 'foo'},\n            {'annotator': 'a', 'text': 'foobar'},\n            {'annotator': 'b', 'text': 'foo'},\n            {'annotator': 'b', 'text': 'foobar'}\n        ]\n        result = LazyLines(data).select(\"annotator\", \"text\")\n        assert result.collect() == expected\n        ```\n        \"\"\"\ndef new_gen():\nfor ex in self.g:\nyield {k: v for k, v in ex.items() if k in args}\nreturn LazyLines(g=new_gen())\ndef drop(self, *args) -&gt; LazyLines:\n\"\"\"\n        Drop specific keys from each dictionary.\n        Arguments:\n            keys: the names of the keys to be kept around\n        Usage:\n        ```python\n        from lazylines import LazyLines\n        data = [\n            {'accept': True, 'annotator': 'a', 'text': 'foo'},\n            {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n            {'accept': True, 'annotator': 'b', 'text': 'foo'},\n            {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n        ]\n        expected = [\n            {'annotator': 'a', 'text': 'foo'},\n            {'annotator': 'a', 'text': 'foobar'},\n            {'annotator': 'b', 'text': 'foo'},\n            {'annotator': 'b', 'text': 'foobar'}\n        ]\n        result = LazyLines(data).drop(\"accept\")\n        assert result.collect() == expected\n        ```\n        \"\"\"\ndef new_gen():\nfor ex in self.g:\nyield {k: v for k, v in ex.items() if k not in args}\nreturn LazyLines(g=new_gen())\ndef pipe(self, func, *args, **kwargs) -&gt; LazyLines:\n\"\"\"Call a function over the entire generator.\"\"\"\nreturn LazyLines(g=func(self, *args, **kwargs))\ndef foreach(self, func, *args, **kwargs) -&gt; LazyLines:\n\"\"\"Just call a function on each dictionary, but pass the original forward.\"\"\"\ndef new_gen():\nfor ex in self.g:\nfunc(ex, *args, **kwargs)\nyield ex\nreturn LazyLines(g=new_gen())\ndef agg(self, **kwargs: Dict[str, Callable]):\ndata = [ex for ex in self.g]\nreturn {\nk: func(data) for k, func in kwargs.items()\n}\n</code></pre>"},{"location":"api/#lazylines.LazyLines.cache","title":"<code>cache()</code>","text":"<p>Cache the result internally by turning it into a list.</p> <p>It's recommended to store the result into another variable.</p> <pre><code>from lazylines import LazyLines\nitems = ({\"a\": i} for i in range(100))\n# The intermediate representation is now a list.\ncached = (LazyLines(items).cache())\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def cache(self) -&gt; LazyLines:\n\"\"\"\n    Cache the result internally by turning it into a list.\n    It's recommended to store the result into another variable.\n    ```python\n    from lazylines import LazyLines\n    items = ({\"a\": i} for i in range(100))\n    # The intermediate representation is now a list.\n    cached = (LazyLines(items).cache())\n    ```\n    \"\"\"\nreturn LazyLines(g=list(self.g))\n</code></pre>"},{"location":"api/#lazylines.LazyLines.collect","title":"<code>collect()</code>","text":"<p>Turns the (final) sequence into a list.</p> <p>Note that, as a consequence, this will also empty the lazyline object.</p> Source code in <code>lazylines/__init__.py</code> <pre><code>def collect(self) -&gt; LazyLines:\n\"\"\"\n    Turns the (final) sequence into a list.\n    Note that, as a consequence, this will also empty the lazyline object.\n    \"\"\"\nreturn [ex for ex in self.g]\n</code></pre>"},{"location":"api/#lazylines.LazyLines.drop","title":"<code>drop(*args)</code>","text":"<p>Drop specific keys from each dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <p>the names of the keys to be kept around</p> required <p>Usage:</p> <pre><code>from lazylines import LazyLines\ndata = [\n{'accept': True, 'annotator': 'a', 'text': 'foo'},\n{'accept': True, 'annotator': 'a', 'text': 'foobar'},\n{'accept': True, 'annotator': 'b', 'text': 'foo'},\n{'accept': True, 'annotator': 'b', 'text': 'foobar'}\n]\nexpected = [\n{'annotator': 'a', 'text': 'foo'},\n{'annotator': 'a', 'text': 'foobar'},\n{'annotator': 'b', 'text': 'foo'},\n{'annotator': 'b', 'text': 'foobar'}\n]\nresult = LazyLines(data).drop(\"accept\")\nassert result.collect() == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def drop(self, *args) -&gt; LazyLines:\n\"\"\"\n    Drop specific keys from each dictionary.\n    Arguments:\n        keys: the names of the keys to be kept around\n    Usage:\n    ```python\n    from lazylines import LazyLines\n    data = [\n        {'accept': True, 'annotator': 'a', 'text': 'foo'},\n        {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n        {'accept': True, 'annotator': 'b', 'text': 'foo'},\n        {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n    ]\n    expected = [\n        {'annotator': 'a', 'text': 'foo'},\n        {'annotator': 'a', 'text': 'foobar'},\n        {'annotator': 'b', 'text': 'foo'},\n        {'annotator': 'b', 'text': 'foobar'}\n    ]\n    result = LazyLines(data).drop(\"accept\")\n    assert result.collect() == expected\n    ```\n    \"\"\"\ndef new_gen():\nfor ex in self.g:\nyield {k: v for k, v in ex.items() if k not in args}\nreturn LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.foreach","title":"<code>foreach(func, *args, **kwargs)</code>","text":"<p>Just call a function on each dictionary, but pass the original forward.</p> Source code in <code>lazylines/__init__.py</code> <pre><code>def foreach(self, func, *args, **kwargs) -&gt; LazyLines:\n\"\"\"Just call a function on each dictionary, but pass the original forward.\"\"\"\ndef new_gen():\nfor ex in self.g:\nfunc(ex, *args, **kwargs)\nyield ex\nreturn LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.head","title":"<code>head(n=5)</code>","text":"<p>Make a subset and only return the top <code>n</code> items.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <p>the number of examples to take</p> <code>5</code> Source code in <code>lazylines/__init__.py</code> <pre><code>def head(self, n=5) -&gt; LazyLines:\n\"\"\"\n    Make a subset and only return the top `n` items.\n    Arguments:\n        n: the number of examples to take\n    \"\"\"\nif isinstance(self.g, list):\nreturn LazyLines(g=(i for i in self.g[:5]))\ndef new_gen():\nfor _ in range(n):\nyield next(self.g)\nreturn LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.keep","title":"<code>keep(*args)</code>","text":"<p>Only keep a subset of the items in the generator based on lambda.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Callable</code> <p>functions that can be used to filter the data, if it outputs <code>True</code> it will be kept around</p> <code>()</code> <p>Usage:</p> <pre><code>from lazylines import LazyLines\nitems = [{\"a\": 2}, {\"a\": 3}]\nresults = (LazyLines(items).keep(lambda d: d[\"a\"] % 2 == 0))\nexpected = [{\"a\": 2}]\nassert results.collect() == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def keep(self, *args: Callable) -&gt; LazyLines:\n\"\"\"\n    Only keep a subset of the items in the generator based on lambda.\n    Arguments:\n        args: functions that can be used to filter the data, if it outputs `True` it will be kept around\n    **Usage**:\n    ```python\n    from lazylines import LazyLines\n    items = [{\"a\": 2}, {\"a\": 3}]\n    results = (LazyLines(items).keep(lambda d: d[\"a\"] % 2 == 0))\n    expected = [{\"a\": 2}]\n    assert results.collect() == expected\n    ```\n    \"\"\"\ndef new_gen():\nfor item in self.g:\nfor func in args:\nif func(item):\nyield item\nreturn LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.map","title":"<code>map(func)</code>","text":"<p>Apply a function to each item before yielding it back.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>the function to call on each item</p> required Source code in <code>lazylines/__init__.py</code> <pre><code>def map(self, func: Callable) -&gt; LazyLines:\n\"\"\"\n    Apply a function to each item before yielding it back.\n    Arguments:\n        func: the function to call on each item\n    \"\"\"\ndef new_gen():\nfor item in self.g:\nyield func(item)\nreturn LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.mutate","title":"<code>mutate(**kwargs)</code>","text":"<p>Adds/overwrites keys in the dictionary based on lambda.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Dict[str, Callable]</code> <p>str/callable pairs that represent keys and a function to calculate it's value</p> <code>{}</code> <p>Usage:</p> <pre><code>from lazylines import LazyLines\nitems = [{\"a\": 2}, {\"a\": 3}]\nresults = (LazyLines(items).mutate(b=lambda d: d[\"a\"] * 2))\nexpected = [{\"a\": 2, \"b\": 4}, {\"a\": 3, \"b\": 6}]\nassert results.collect() == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def mutate(self, **kwargs: Dict[str, Callable]) -&gt; LazyLines:\n\"\"\"\n    Adds/overwrites keys in the dictionary based on lambda.\n    Arguments:\n        kwargs: str/callable pairs that represent keys and a function to calculate it's value\n    **Usage**:\n    ```python\n    from lazylines import LazyLines\n    items = [{\"a\": 2}, {\"a\": 3}]\n    results = (LazyLines(items).mutate(b=lambda d: d[\"a\"] * 2))\n    expected = [{\"a\": 2, \"b\": 4}, {\"a\": 3, \"b\": 6}]\n    assert results.collect() == expected\n    ```\n    \"\"\"\ndef new_gen():\nfor item in self.g:\nfor k, v in kwargs.items():\nitem[k] = v(item)\nyield item\nreturn LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.nest_by","title":"<code>nest_by(*keys)</code>","text":"<p>Group by keys and return nested collections.</p> <p>The opposite of <code>.unnest()</code></p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>str</code> <p>the keys to nest by</p> <code>()</code> <p>Usage:</p> <pre><code>from lazylines import LazyLines\ndata = [\n{'accept': True, 'annotator': 'a', 'text': 'foo'},\n{'accept': True, 'annotator': 'a', 'text': 'foobar'},\n{'accept': True, 'annotator': 'b', 'text': 'foo'},\n{'accept': True, 'annotator': 'b', 'text': 'foobar'}\n]\nexpected = [\n{'annotator': 'a',\n'subset': [{'accept': True, 'text': 'foo'},\n{'accept': True, 'text': 'foobar'}]},\n{'annotator': 'b',\n'subset': [{'accept': True, 'text': 'foo'},\n{'accept': True, 'text': 'foobar'}]}\n]\nresult = LazyLines(data).nest_by(\"annotator\")\nassert result.collect() == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def nest_by(self, *keys: str) -&gt; LazyLines:\n\"\"\"\n    Group by keys and return nested collections.\n    The opposite of `.unnest()`\n    Arguments:\n        keys: the keys to nest by\n    **Usage**:\n    ```python\n    from lazylines import LazyLines\n    data = [\n        {'accept': True, 'annotator': 'a', 'text': 'foo'},\n        {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n        {'accept': True, 'annotator': 'b', 'text': 'foo'},\n        {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n    ]\n    expected = [\n            {'annotator': 'a',\n             'subset': [{'accept': True, 'text': 'foo'},\n                        {'accept': True, 'text': 'foobar'}]},\n            {'annotator': 'b',\n             'subset': [{'accept': True, 'text': 'foo'},\n                        {'accept': True, 'text': 'foobar'}]}\n    ]\n    result = LazyLines(data).nest_by(\"annotator\")\n    assert result.collect() == expected\n    ```\n    \"\"\"\ngroups = {}\nfor example in self.g:\nkey = tuple(example.get(arg, None) for arg in args)\nif key not in groups:\ngroups[key] = []\nfor arg in args:\ndel example[arg]\ngroups[key].append(example)\nresult = []\nfor key, values in groups.items():\nresult.append({**{k: v for k, v in zip(args, key)}, \"subset\": values})\nreturn LazyLines(result)\n</code></pre>"},{"location":"api/#lazylines.LazyLines.pipe","title":"<code>pipe(func, *args, **kwargs)</code>","text":"<p>Call a function over the entire generator.</p> Source code in <code>lazylines/__init__.py</code> <pre><code>def pipe(self, func, *args, **kwargs) -&gt; LazyLines:\n\"\"\"Call a function over the entire generator.\"\"\"\nreturn LazyLines(g=func(self, *args, **kwargs))\n</code></pre>"},{"location":"api/#lazylines.LazyLines.progress","title":"<code>progress()</code>","text":"<p>Adds a progress bar. Meant to be used early.</p> <p>Will also run through the entire stream once to calculate the stream size.</p> Source code in <code>lazylines/__init__.py</code> <pre><code>def progress(self) -&gt; LazyLines:\n\"\"\"\n    Adds a progress bar. Meant to be used early.\n    Will also run through the entire stream once to calculate the stream size.\n    \"\"\"\nstream_orig, stream_copy = it.tee(self.g)\ntotal = sum(1 for _ in stream_copy)\nreturn LazyLines(g=tqdm.tqdm(stream_orig, total=total))\n</code></pre>"},{"location":"api/#lazylines.LazyLines.rename","title":"<code>rename(**kwargs)</code>","text":"<p>Rename a few keys in each item.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Dict[str, str]</code> <p>str/str pairs that resemble the new name and old name of a key</p> <code>{}</code> <p>Usage:</p> <pre><code>from lazylines import LazyLines\ndata = [\n{'labeller': 'a', 'text': 'foo'},\n{'labeller': 'a', 'text': 'foobar'},\n{'labeller': 'b', 'text': 'foo'},\n{'labeller': 'b', 'text': 'foobar'}\n]\nexpected = [\n{'annotator': 'a', 'text': 'foo'},\n{'annotator': 'a', 'text': 'foobar'},\n{'annotator': 'b', 'text': 'foo'},\n{'annotator': 'b', 'text': 'foobar'}\n]\nresult = (LazyLines(data).rename(annotator=\"labeller\").collect())\nassert result == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def rename(self, **kwargs: Dict[str, str]) -&gt; LazyLines:\n\"\"\"\n    Rename a few keys in each item.\n    Arguments:\n        kwargs: str/str pairs that resemble the new name and old name of a key\n    Usage:\n    ```python\n    from lazylines import LazyLines\n    data = [\n        {'labeller': 'a', 'text': 'foo'},\n        {'labeller': 'a', 'text': 'foobar'},\n        {'labeller': 'b', 'text': 'foo'},\n        {'labeller': 'b', 'text': 'foobar'}\n    ]\n    expected = [\n        {'annotator': 'a', 'text': 'foo'},\n        {'annotator': 'a', 'text': 'foobar'},\n        {'annotator': 'b', 'text': 'foo'},\n        {'annotator': 'b', 'text': 'foobar'}\n    ]\n    result = (LazyLines(data).rename(annotator=\"labeller\").collect())\n    assert result == expected\n    ```\n    \"\"\"\ndef new_gen():\nfor item in self.g:\nnew_items = {k: item[v] for k, v in kwargs.items()}\nyield {**item, **new_items}\nreturn LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.select","title":"<code>select(*keys)</code>","text":"<p>Only select specific keys from each dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>str</code> <p>the names of the keys to be kept around</p> <code>()</code> <p>Usage:</p> <pre><code>from lazylines import LazyLines\ndata = [\n{'accept': True, 'annotator': 'a', 'text': 'foo'},\n{'accept': True, 'annotator': 'a', 'text': 'foobar'},\n{'accept': True, 'annotator': 'b', 'text': 'foo'},\n{'accept': True, 'annotator': 'b', 'text': 'foobar'}\n]\nexpected = [\n{'annotator': 'a', 'text': 'foo'},\n{'annotator': 'a', 'text': 'foobar'},\n{'annotator': 'b', 'text': 'foo'},\n{'annotator': 'b', 'text': 'foobar'}\n]\nresult = LazyLines(data).select(\"annotator\", \"text\")\nassert result.collect() == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def select(self, *keys: str) -&gt; LazyLines:\n\"\"\"\n    Only select specific keys from each dictionary.\n    Arguments:\n        keys: the names of the keys to be kept around\n    Usage:\n    ```python\n    from lazylines import LazyLines\n    data = [\n        {'accept': True, 'annotator': 'a', 'text': 'foo'},\n        {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n        {'accept': True, 'annotator': 'b', 'text': 'foo'},\n        {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n    ]\n    expected = [\n        {'annotator': 'a', 'text': 'foo'},\n        {'annotator': 'a', 'text': 'foobar'},\n        {'annotator': 'b', 'text': 'foo'},\n        {'annotator': 'b', 'text': 'foobar'}\n    ]\n    result = LazyLines(data).select(\"annotator\", \"text\")\n    assert result.collect() == expected\n    ```\n    \"\"\"\ndef new_gen():\nfor ex in self.g:\nyield {k: v for k, v in ex.items() if k in args}\nreturn LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.show","title":"<code>show(n=5)</code>","text":"<p>Give a preview of the first <code>n</code> examples. </p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>the number of examples to preview</p> <code>5</code> Source code in <code>lazylines/__init__.py</code> <pre><code>def show(self, n: int=5) -&gt; LazyLines:\n\"\"\"\n    Give a preview of the first `n` examples. \n    Arguments:\n        n: the number of examples to preview\n    \"\"\"\nstream_orig, stream_copy = it.tee(self.g)\nfor _ in range(n):\npprint.pprint(next(stream_copy))\nreturn LazyLines(g=stream_orig)\n</code></pre>"},{"location":"api/#lazylines.LazyLines.sort_by","title":"<code>sort_by(*keys)</code>","text":"<p>Sort the items based on a subset of the keys.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>str</code> <p>the keys to use for sorting</p> <code>()</code> Source code in <code>lazylines/__init__.py</code> <pre><code>def sort_by(self, *keys: str) -&gt; LazyLines:\n\"\"\"\n    Sort the items based on a subset of the keys.\n    Arguments:\n        keys: the keys to use for sorting\n    \"\"\"\nreturn LazyLines(g=sorted(self.g, key=lambda d: tuple([d[c] for c in keys])))\n</code></pre>"},{"location":"api/#lazylines.LazyLines.tee","title":"<code>tee(n=2)</code>","text":"<p>Copies the lazylines.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>how often to <code>tee</code> the stream</p> <code>2</code> <p>Usage:</p> <pre><code>from lazylines import LazyLines\ndata = [\n{'accept': True, 'annotator': 'a', 'text': 'foo'},\n{'accept': True, 'annotator': 'a', 'text': 'foobar'},\n{'accept': True, 'annotator': 'b', 'text': 'foo'},\n{'accept': True, 'annotator': 'b', 'text': 'foobar'}\n]\nlines1, lines2 = LazyLines(data).tee(n=2)\nlines1, lines2, lines3 = LazyLines(data).tee(n=3)\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def tee(self, n:int=2) -&gt; Tuple[LazyLines]:\n\"\"\"\n    Copies the lazylines.\n    Arguments:\n        n: how often to `tee` the stream\n    Usage:\n    ```python\n    from lazylines import LazyLines\n    data = [\n        {'accept': True, 'annotator': 'a', 'text': 'foo'},\n        {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n        {'accept': True, 'annotator': 'b', 'text': 'foo'},\n        {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n    ]\n    lines1, lines2 = LazyLines(data).tee(n=2)\n    lines1, lines2, lines3 = LazyLines(data).tee(n=3)\n    ```\n    \"\"\"\nreturn tuple(LazyLines(g=gen) for gen in it.tee(self.g, n))\n</code></pre>"},{"location":"api/#lazylines.LazyLines.unnest","title":"<code>unnest(key)</code>","text":"<p>Explodes a key, effectively un-nesting it.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the key to un-nest</p> required <p>Usage:</p> <pre><code>from lazylines import LazyLines\ndata = [{'annotator': 'a',\n'subset': [{'accept': True, 'text': 'foo'},\n{'accept': True, 'text': 'foobar'}]},\n{'annotator': 'b',\n'subset': [{'accept': True, 'text': 'foo'},\n{'accept': True, 'text': 'foobar'}]}]\nexpected = [\n{'accept': True, 'annotator': 'a', 'text': 'foo'},\n{'accept': True, 'annotator': 'a', 'text': 'foobar'},\n{'accept': True, 'annotator': 'b', 'text': 'foo'},\n{'accept': True, 'annotator': 'b', 'text': 'foobar'}\n]\nresult = LazyLines(data).unnest(\"subset\")\nassert result.collect() == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def unnest(self, key: str) -&gt; LazyLines:\n\"\"\"\n    Explodes a key, effectively un-nesting it.\n    Arguments:\n        key: the key to un-nest\n    **Usage**:\n    ```python\n    from lazylines import LazyLines\n    data = [{'annotator': 'a',\n             'subset': [{'accept': True, 'text': 'foo'},\n                        {'accept': True, 'text': 'foobar'}]},\n            {'annotator': 'b',\n             'subset': [{'accept': True, 'text': 'foo'},\n                        {'accept': True, 'text': 'foobar'}]}]\n    expected = [\n        {'accept': True, 'annotator': 'a', 'text': 'foo'},\n        {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n        {'accept': True, 'annotator': 'b', 'text': 'foo'},\n        {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n    ]\n    result = LazyLines(data).unnest(\"subset\")\n    assert result.collect() == expected\n    ```\n    \"\"\"\ndef new_gen():\nfor item in self.g:\nfor value in item[key]:\norig = {k: v for k, v in item.items() if k != key}\nd = {**{key: value}, **orig}\nyield d\nreturn LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.write_jsonl","title":"<code>write_jsonl(path, append=False, append_new_line=True)</code>","text":"<p>Write everything into a jsonl file.</p> <p>Note that, as a consequence, this will also empty the lazyline object.</p> Source code in <code>lazylines/__init__.py</code> <pre><code>def write_jsonl(\nself, path, append: bool = False, append_new_line: bool = True\n) -&gt; LazyLines:\n\"\"\"\n    Write everything into a jsonl file.\n    Note that, as a consequence, this will also empty the lazyline object.\n    \"\"\"\nsrsly.write_jsonl(path, self.g, append=append, append_new_line=append_new_line)\n</code></pre>"}]}