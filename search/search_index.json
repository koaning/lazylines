{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>Lazylines is a small Python library that makes it easier to work with lists of dictionaries as well as JSONL files. It was originally designed to help handle some boilerplate for some of my custom Prodigy recipes.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>To give a demo of what the base useage might look like, let's download a .jsonl file. </p> <pre><code>wget https://calmcode.io/datasets/pokemon.jsonl\n</code></pre> <p>This file has data that looks like this: </p> <pre><code>{\"attack\": 49, \"hp\": 45, \"name\": \"Bulbasaur\", \"total\": 318, \"type\": [\"Grass\", \"Poison\"]}\n{\"attack\": 62, \"hp\": 60, \"name\": \"Ivysaur\", \"total\": 405, \"type\": [\"Grass\", \"Poison\"]}\n</code></pre> <pre><code>from lazylines import read_jsonl\n(\nread_jsonl(\"tests/pokemon.jsonl\")\n.unnest(\"type\")\n.nest_by(\"type\")\n.mutate(count=lambda d: len(d['subset']))\n.drop(\"subset\")\n.collect()\n)\n</code></pre> <p>Let's go through everything happening line-by-line. </p> <ol> <li>First we read the file with <code>read_jsonl</code>. Internally, it's stored as a generator, so no data is actually being read just yet. </li> <li>Next, we unnest the list in the <code>\"type\"</code> key. This turns an item with a nested example into two examples each containing one of the nested items.  </li> <li>Next, we nest by the type again. This allows us to have an item for each <code>\"type\"</code> together with a <code>\"subset\"</code> key that contains all relevant examples that belong to the <code>\"type\"</code>. </li> <li>Next, we add a key called <code>\"count\"</code> by calculating the length of the subset. </li> <li>Next, we drop the <code>\"subset\"</code> key. </li> <li>Finally, we <code>collect()</code> the data. All the previous steps were \"lazy\", only when we call <code>collect()</code> do we actually perform the operations in the chain. </li> </ol> <p>This is what the output looks like. </p> <pre><code>[{'type': 'Grass', 'count': 95},\n{'type': 'Poison', 'count': 62},\n{'type': 'Fire', 'count': 64},\n{'type': 'Flying', 'count': 101},\n{'type': 'Dragon', 'count': 50},\n{'type': 'Water', 'count': 126},\n{'type': 'Bug', 'count': 72},\n{'type': 'Normal', 'count': 102},\n{'type': 'Electric', 'count': 50},\n{'type': 'Ground', 'count': 67},\n{'type': 'Fairy', 'count': 40},\n{'type': 'Fighting', 'count': 53},\n{'type': 'Psychic', 'count': 90},\n{'type': 'Rock', 'count': 58},\n{'type': 'Steel', 'count': 49},\n{'type': 'Ice', 'count': 38},\n{'type': 'Ghost', 'count': 46},\n{'type': 'Dark', 'count': 51}]\n</code></pre> <p>There's a lot that you can do just by nesting and unnesting and this library tries to make it easy to perform common data wrangling tasks without having to resort to heavy dependencies.</p>"},{"location":"#fun-features","title":"Fun Features","text":"<p>There are a few fun features to mention out loud. </p>"},{"location":"#progress-bars","title":"Progress bars","text":"<p>If you have long running tasks you can keep track of the progress via the <code>.progress()</code> method. </p> <pre><code>import time \nfrom lazylines import read_jsonl\n(\nread_jsonl(\"tests/pokemon.jsonl\")\n.progress()\n.foreach(lambda d: time.sleep(0.02))\n.collect()\n)\n</code></pre> <p>The <code>foreach</code> method runs a function for each item and then returns the original item. The <code>progress</code> method adds the progress bar. </p>"},{"location":"#intermediate-results","title":"Intermediate results","text":"<p>It can help to \"see\" what is happening in each step in a pipeline.  For these use-cases you can use the <code>.show()</code> method. </p> <pre><code>from lazylines import read_jsonl\n(\nread_jsonl(\"tests/pokemon.jsonl\")\n.show(2)\n.unnest(\"type\")\n.show(2)\n)\n</code></pre> <p>The first call to <code>.show(2)</code> will render: </p> <pre><code>{'attack': 49,\n'hp': 45,\n'name': 'Bulbasaur',\n'total': 318,\n'type': ['Grass', 'Poison']}\n{'attack': 62,\n'hp': 60,\n'name': 'Ivysaur',\n'total': 405,\n'type': ['Grass', 'Poison']}\n</code></pre> <p>The second call to <code>.show(2)</code> will render: </p> <pre><code>{'attack': 49, 'hp': 45, 'name': 'Bulbasaur', 'total': 318, 'type': 'Grass'}\n{'attack': 49, 'hp': 45, 'name': 'Bulbasaur', 'total': 318, 'type': 'Poison'}\n</code></pre>"},{"location":"#learn-more","title":"Learn More","text":"<p>To learn more, check the API guide. </p>"},{"location":"api/","title":"API","text":""},{"location":"api/#lazylines.read_jsonl","title":"<code>lazylines.read_jsonl(path)</code>","text":"<p>Read .jsonl file and turn it into a LazyLines object.</p> Source code in <code>lazylines/__init__.py</code> <pre><code>def read_jsonl(path: Union[str, Path]) -&gt; LazyLines:\n\"\"\"Read .jsonl file and turn it into a LazyLines object.\"\"\"\nreturn LazyLines(srsly.read_jsonl(path))\n</code></pre>"},{"location":"api/#lazylines.LazyLines","title":"<code>lazylines.LazyLines</code>","text":"<p>An object that can wrangle iterables of dictionaries (similar to JSONL).</p> <pre><code>from lazylines import LazyLines\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>class LazyLines:\n\"\"\"\n    An object that can wrangle iterables of dictionaries (similar to JSONL).\n    ```python\n    from lazylines import LazyLines\n    ```\n    \"\"\"\ndef __init__(self, g):\nself.g = g\nself.groups = set()\ndef cache(self) -&gt; LazyLines:\n\"\"\"\n        Cache the result internally by turning it into a list.\n        It's recommended to store the result into another variable.\n        ```python\n        from lazylines import LazyLines\n        items = ({\"a\": i} for i in range(100))\n        # The intermediate representation is now a list.\n        cached = (LazyLines(items).cache())\n        ```\n        \"\"\"\nreturn LazyLines(g=list(self.g))\ndef mutate(self, **kwargs: Dict[str, Callable]) -&gt; LazyLines:\n\"\"\"\n        Adds/overwrites keys in the dictionary based on lambda.\n        Arguments:\n            kwargs: str/callable pairs that represent keys and a function to calculate it's value\n        **Usage**:\n        ```python\n        from lazylines import LazyLines\n        items = [{\"a\": 2}, {\"a\": 3}]\n        results = (LazyLines(items).mutate(b=lambda d: d[\"a\"] * 2))\n        expected = [{\"a\": 2, \"b\": 4}, {\"a\": 3, \"b\": 6}]\n        assert results.collect() == expected\n        ```\n        \"\"\"\ndef new_gen():\nfor item in self.g:\nfor k, v in kwargs.items():\nitem[k] = v(item)\nyield item\nreturn LazyLines(g=new_gen())\ndef keep(self, *args: Callable) -&gt; LazyLines:\n\"\"\"\n        Only keep a subset of the items in the generator based on lambda.\n        Arguments:\n            args: functions that can be used to filter the data, if it outputs `True` it will be kept around\n        **Usage**:\n        ```python\n        from lazylines import LazyLines\n        items = [{\"a\": 2}, {\"a\": 3}]\n        results = (LazyLines(items).keep(lambda d: d[\"a\"] % 2 == 0))\n        expected = [{\"a\": 2}]\n        assert results.collect() == expected\n        ```\n        \"\"\"\ndef new_gen():\nfor item in self.g:\nallowed = True\nfor func in args:\nif not func(item):\nallowed = False\nif allowed:\nyield item\nreturn LazyLines(g=new_gen())\ndef unnest(self, key: str=\"subset\") -&gt; LazyLines:\n\"\"\"\n        Explodes a key, effectively un-nesting it.\n        Arguments:\n            key: the key to un-nest\n        **Usage**:\n        ```python\n        from lazylines import LazyLines\n        data = [{'annotator': 'a',\n                 'subset': [{'accept': True, 'text': 'foo'},\n                            {'accept': True, 'text': 'foobar'}]},\n                {'annotator': 'b',\n                 'subset': [{'accept': True, 'text': 'foo'},\n                            {'accept': True, 'text': 'foobar'}]}]\n        expected = [\n            {'accept': True, 'annotator': 'a', 'text': 'foo'},\n            {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n            {'accept': True, 'annotator': 'b', 'text': 'foo'},\n            {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n        ]\n        result = LazyLines(data).unnest(\"subset\")\n        assert result.collect() == expected\n        ```\n        \"\"\"\ndef new_gen():\nfor item in self.g:\nfor value in item[key]:\norig = {k: v for k, v in item.items() if k != key}\nd = {**{key: value}, **orig}\nyield d\nreturn LazyLines(g=new_gen())\ndef head(self, n=5) -&gt; LazyLines:\n\"\"\"\n        Make a subset and only return the top `n` items.\n        Arguments:\n            n: the number of examples to take\n        \"\"\"\nif isinstance(self.g, list):\nreturn LazyLines(g=(i for i in self.g[:5]))\ndef new_gen():\nfor _ in range(n):\nyield next(self.g)\nreturn LazyLines(g=new_gen())\ndef show(self, n: int=5) -&gt; LazyLines:\n\"\"\"\n        Give a preview of the first `n` examples. \n        Arguments:\n            n: the number of examples to preview\n        \"\"\"\nstream_orig, stream_copy = it.tee(self.g)\nfor _ in range(n):\npprint.pprint(next(stream_copy))\nreturn LazyLines(g=stream_orig)\ndef map(self, func: Callable) -&gt; LazyLines:\n\"\"\"\n        Apply a function to each item before yielding it back.\n        Arguments:\n            func: the function to call on each item\n        \"\"\"\ndef new_gen():\nfor item in self.g:\nyield func(item)\nreturn LazyLines(g=new_gen())\ndef tee(self, n:int=2) -&gt; Tuple[LazyLines]:\n\"\"\"\n        Copies the lazylines.\n        Arguments:\n            n: how often to `tee` the stream\n        Usage:\n        ```python\n        from lazylines import LazyLines\n        data = [\n            {'accept': True, 'annotator': 'a', 'text': 'foo'},\n            {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n            {'accept': True, 'annotator': 'b', 'text': 'foo'},\n            {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n        ]\n        lines1, lines2 = LazyLines(data).tee(n=2)\n        lines1, lines2, lines3 = LazyLines(data).tee(n=3)\n        ```\n        \"\"\"\nreturn tuple(LazyLines(g=gen) for gen in it.tee(self.g, n))\ndef __iter__(self):\nreturn iter(self.g)\ndef sort_by(self, *keys: str) -&gt; LazyLines:\n\"\"\"\n        Sort the items based on a subset of the keys.\n        Arguments:\n            keys: the keys to use for sorting\n        \"\"\"\nreturn LazyLines(g=sorted(self.g, key=lambda d: tuple([d[c] for c in keys])))\ndef rename(self, **kwargs: Dict[str, str]) -&gt; LazyLines:\n\"\"\"\n        Rename a few keys in each item.\n        Arguments:\n            kwargs: str/str pairs that resemble the new name and old name of a key\n        Usage:\n        ```python\n        from lazylines import LazyLines\n        data = [\n            {'labeller': 'a', 'text': 'foo'},\n            {'labeller': 'a', 'text': 'foobar'},\n            {'labeller': 'b', 'text': 'foo'},\n            {'labeller': 'b', 'text': 'foobar'}\n        ]\n        expected = [\n            {'annotator': 'a', 'text': 'foo'},\n            {'annotator': 'a', 'text': 'foobar'},\n            {'annotator': 'b', 'text': 'foo'},\n            {'annotator': 'b', 'text': 'foobar'}\n        ]\n        result = (LazyLines(data).rename(annotator=\"labeller\").collect())\n        assert result == expected\n        ```\n        \"\"\"\ndef new_gen():\nfor item in self.g:\nnew_items = {k: item[v] for k, v in kwargs.items()}\nyield {**item, **new_items}\nreturn LazyLines(g=new_gen())\ndef nest_by(self, *keys: str) -&gt; LazyLines:\n\"\"\"\n        Group by keys and return nested collections.\n        The opposite of `.unnest()`\n        Arguments:\n            keys: the keys to nest by\n        **Usage**:\n        ```python\n        from lazylines import LazyLines\n        data = [\n            {'accept': True, 'annotator': 'a', 'text': 'foo'},\n            {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n            {'accept': True, 'annotator': 'b', 'text': 'foo'},\n            {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n        ]\n        expected = [\n                {'annotator': 'a',\n                 'subset': [{'accept': True, 'text': 'foo'},\n                            {'accept': True, 'text': 'foobar'}]},\n                {'annotator': 'b',\n                 'subset': [{'accept': True, 'text': 'foo'},\n                            {'accept': True, 'text': 'foobar'}]}\n        ]\n        result = LazyLines(data).nest_by(\"annotator\")\n        assert result.collect() == expected\n        ```\n        \"\"\"\ngroups = {}\nfor example in self.g:\nkey = tuple(example.get(arg, None) for arg in keys)\nif key not in groups:\ngroups[key] = []\nfor arg in keys:\ndel example[arg]\ngroups[key].append(example)\nresult = []\nfor key, values in groups.items():\nresult.append({**{k: v for k, v in zip(keys, key)}, \"subset\": values})\nreturn LazyLines(result)\ndef progress(self) -&gt; LazyLines:\n\"\"\"\n        Adds a progress bar. Meant to be used early.\n        Will also run through the entire stream once to calculate the stream size.\n        \"\"\"\nstream_orig, stream_copy = it.tee(self.g)\ntotal = sum(1 for _ in stream_copy)\nreturn LazyLines(g=tqdm.tqdm(stream_orig, total=total))\ndef collect(self) -&gt; LazyLines:\n\"\"\"\n        Turns the (final) sequence into a list.\n        Note that, as a consequence, this will also empty the lazyline object.\n        \"\"\"\nreturn [ex for ex in self.g]\ndef write_jsonl(\nself, path, append: bool = False, append_new_line: bool = True\n) -&gt; LazyLines:\n\"\"\"\n        Write everything into a jsonl file.\n        Note that, as a consequence, this will also empty the lazyline object.\n        \"\"\"\nsrsly.write_jsonl(path, self.g, append=append, append_new_line=append_new_line)\ndef select(self, *keys: str) -&gt; LazyLines:\n\"\"\"\n        Only select specific keys from each dictionary.\n        Arguments:\n            keys: the names of the keys to be kept around\n        Usage:\n        ```python\n        from lazylines import LazyLines\n        data = [\n            {'accept': True, 'annotator': 'a', 'text': 'foo'},\n            {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n            {'accept': True, 'annotator': 'b', 'text': 'foo'},\n            {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n        ]\n        expected = [\n            {'annotator': 'a', 'text': 'foo'},\n            {'annotator': 'a', 'text': 'foobar'},\n            {'annotator': 'b', 'text': 'foo'},\n            {'annotator': 'b', 'text': 'foobar'}\n        ]\n        result = LazyLines(data).select(\"annotator\", \"text\")\n        assert result.collect() == expected\n        ```\n        \"\"\"\ndef new_gen():\nfor ex in self.g:\nyield {k: v for k, v in ex.items() if k in keys}\nreturn LazyLines(g=new_gen())\ndef drop(self, *args) -&gt; LazyLines:\n\"\"\"\n        Drop specific keys from each dictionary.\n        Arguments:\n            keys: the names of the keys to be kept around\n        Usage:\n        ```python\n        from lazylines import LazyLines\n        data = [\n            {'accept': True, 'annotator': 'a', 'text': 'foo'},\n            {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n            {'accept': True, 'annotator': 'b', 'text': 'foo'},\n            {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n        ]\n        expected = [\n            {'annotator': 'a', 'text': 'foo'},\n            {'annotator': 'a', 'text': 'foobar'},\n            {'annotator': 'b', 'text': 'foo'},\n            {'annotator': 'b', 'text': 'foobar'}\n        ]\n        result = LazyLines(data).drop(\"accept\")\n        assert result.collect() == expected\n        ```\n        \"\"\"\ndef new_gen():\nfor ex in self.g:\nyield {k: v for k, v in ex.items() if k not in args}\nreturn LazyLines(g=new_gen())\ndef pipe(self, func, *args, **kwargs) -&gt; LazyLines:\n\"\"\"Call a function over the entire generator.\"\"\"\nreturn LazyLines(g=func(self, *args, **kwargs))\ndef foreach(self, func, *args, **kwargs) -&gt; LazyLines:\n\"\"\"Just call a function on each dictionary, but pass the original forward.\"\"\"\ndef new_gen():\nfor ex in self.g:\nfunc(ex, *args, **kwargs)\nyield ex\nreturn LazyLines(g=new_gen())\ndef agg(self, **kwargs: Dict[str, Callable]):\ndata = [ex for ex in self.g]\nreturn {\nk: func(data) for k, func in kwargs.items()\n}\n</code></pre>"},{"location":"api/#lazylines.LazyLines.cache","title":"<code>cache()</code>","text":"<p>Cache the result internally by turning it into a list.</p> <p>It's recommended to store the result into another variable.</p> <pre><code>from lazylines import LazyLines\nitems = ({\"a\": i} for i in range(100))\n# The intermediate representation is now a list.\ncached = (LazyLines(items).cache())\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def cache(self) -&gt; LazyLines:\n\"\"\"\n    Cache the result internally by turning it into a list.\n    It's recommended to store the result into another variable.\n    ```python\n    from lazylines import LazyLines\n    items = ({\"a\": i} for i in range(100))\n    # The intermediate representation is now a list.\n    cached = (LazyLines(items).cache())\n    ```\n    \"\"\"\nreturn LazyLines(g=list(self.g))\n</code></pre>"},{"location":"api/#lazylines.LazyLines.collect","title":"<code>collect()</code>","text":"<p>Turns the (final) sequence into a list.</p> <p>Note that, as a consequence, this will also empty the lazyline object.</p> Source code in <code>lazylines/__init__.py</code> <pre><code>def collect(self) -&gt; LazyLines:\n\"\"\"\n    Turns the (final) sequence into a list.\n    Note that, as a consequence, this will also empty the lazyline object.\n    \"\"\"\nreturn [ex for ex in self.g]\n</code></pre>"},{"location":"api/#lazylines.LazyLines.drop","title":"<code>drop(*args)</code>","text":"<p>Drop specific keys from each dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <p>the names of the keys to be kept around</p> required <p>Usage:</p> <pre><code>from lazylines import LazyLines\ndata = [\n{'accept': True, 'annotator': 'a', 'text': 'foo'},\n{'accept': True, 'annotator': 'a', 'text': 'foobar'},\n{'accept': True, 'annotator': 'b', 'text': 'foo'},\n{'accept': True, 'annotator': 'b', 'text': 'foobar'}\n]\nexpected = [\n{'annotator': 'a', 'text': 'foo'},\n{'annotator': 'a', 'text': 'foobar'},\n{'annotator': 'b', 'text': 'foo'},\n{'annotator': 'b', 'text': 'foobar'}\n]\nresult = LazyLines(data).drop(\"accept\")\nassert result.collect() == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def drop(self, *args) -&gt; LazyLines:\n\"\"\"\n    Drop specific keys from each dictionary.\n    Arguments:\n        keys: the names of the keys to be kept around\n    Usage:\n    ```python\n    from lazylines import LazyLines\n    data = [\n        {'accept': True, 'annotator': 'a', 'text': 'foo'},\n        {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n        {'accept': True, 'annotator': 'b', 'text': 'foo'},\n        {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n    ]\n    expected = [\n        {'annotator': 'a', 'text': 'foo'},\n        {'annotator': 'a', 'text': 'foobar'},\n        {'annotator': 'b', 'text': 'foo'},\n        {'annotator': 'b', 'text': 'foobar'}\n    ]\n    result = LazyLines(data).drop(\"accept\")\n    assert result.collect() == expected\n    ```\n    \"\"\"\ndef new_gen():\nfor ex in self.g:\nyield {k: v for k, v in ex.items() if k not in args}\nreturn LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.foreach","title":"<code>foreach(func, *args, **kwargs)</code>","text":"<p>Just call a function on each dictionary, but pass the original forward.</p> Source code in <code>lazylines/__init__.py</code> <pre><code>def foreach(self, func, *args, **kwargs) -&gt; LazyLines:\n\"\"\"Just call a function on each dictionary, but pass the original forward.\"\"\"\ndef new_gen():\nfor ex in self.g:\nfunc(ex, *args, **kwargs)\nyield ex\nreturn LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.head","title":"<code>head(n=5)</code>","text":"<p>Make a subset and only return the top <code>n</code> items.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <p>the number of examples to take</p> <code>5</code> Source code in <code>lazylines/__init__.py</code> <pre><code>def head(self, n=5) -&gt; LazyLines:\n\"\"\"\n    Make a subset and only return the top `n` items.\n    Arguments:\n        n: the number of examples to take\n    \"\"\"\nif isinstance(self.g, list):\nreturn LazyLines(g=(i for i in self.g[:5]))\ndef new_gen():\nfor _ in range(n):\nyield next(self.g)\nreturn LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.keep","title":"<code>keep(*args)</code>","text":"<p>Only keep a subset of the items in the generator based on lambda.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Callable</code> <p>functions that can be used to filter the data, if it outputs <code>True</code> it will be kept around</p> <code>()</code> <p>Usage:</p> <pre><code>from lazylines import LazyLines\nitems = [{\"a\": 2}, {\"a\": 3}]\nresults = (LazyLines(items).keep(lambda d: d[\"a\"] % 2 == 0))\nexpected = [{\"a\": 2}]\nassert results.collect() == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def keep(self, *args: Callable) -&gt; LazyLines:\n\"\"\"\n    Only keep a subset of the items in the generator based on lambda.\n    Arguments:\n        args: functions that can be used to filter the data, if it outputs `True` it will be kept around\n    **Usage**:\n    ```python\n    from lazylines import LazyLines\n    items = [{\"a\": 2}, {\"a\": 3}]\n    results = (LazyLines(items).keep(lambda d: d[\"a\"] % 2 == 0))\n    expected = [{\"a\": 2}]\n    assert results.collect() == expected\n    ```\n    \"\"\"\ndef new_gen():\nfor item in self.g:\nallowed = True\nfor func in args:\nif not func(item):\nallowed = False\nif allowed:\nyield item\nreturn LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.map","title":"<code>map(func)</code>","text":"<p>Apply a function to each item before yielding it back.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>the function to call on each item</p> required Source code in <code>lazylines/__init__.py</code> <pre><code>def map(self, func: Callable) -&gt; LazyLines:\n\"\"\"\n    Apply a function to each item before yielding it back.\n    Arguments:\n        func: the function to call on each item\n    \"\"\"\ndef new_gen():\nfor item in self.g:\nyield func(item)\nreturn LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.mutate","title":"<code>mutate(**kwargs)</code>","text":"<p>Adds/overwrites keys in the dictionary based on lambda.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Dict[str, Callable]</code> <p>str/callable pairs that represent keys and a function to calculate it's value</p> <code>{}</code> <p>Usage:</p> <pre><code>from lazylines import LazyLines\nitems = [{\"a\": 2}, {\"a\": 3}]\nresults = (LazyLines(items).mutate(b=lambda d: d[\"a\"] * 2))\nexpected = [{\"a\": 2, \"b\": 4}, {\"a\": 3, \"b\": 6}]\nassert results.collect() == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def mutate(self, **kwargs: Dict[str, Callable]) -&gt; LazyLines:\n\"\"\"\n    Adds/overwrites keys in the dictionary based on lambda.\n    Arguments:\n        kwargs: str/callable pairs that represent keys and a function to calculate it's value\n    **Usage**:\n    ```python\n    from lazylines import LazyLines\n    items = [{\"a\": 2}, {\"a\": 3}]\n    results = (LazyLines(items).mutate(b=lambda d: d[\"a\"] * 2))\n    expected = [{\"a\": 2, \"b\": 4}, {\"a\": 3, \"b\": 6}]\n    assert results.collect() == expected\n    ```\n    \"\"\"\ndef new_gen():\nfor item in self.g:\nfor k, v in kwargs.items():\nitem[k] = v(item)\nyield item\nreturn LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.nest_by","title":"<code>nest_by(*keys)</code>","text":"<p>Group by keys and return nested collections.</p> <p>The opposite of <code>.unnest()</code></p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>str</code> <p>the keys to nest by</p> <code>()</code> <p>Usage:</p> <pre><code>from lazylines import LazyLines\ndata = [\n{'accept': True, 'annotator': 'a', 'text': 'foo'},\n{'accept': True, 'annotator': 'a', 'text': 'foobar'},\n{'accept': True, 'annotator': 'b', 'text': 'foo'},\n{'accept': True, 'annotator': 'b', 'text': 'foobar'}\n]\nexpected = [\n{'annotator': 'a',\n'subset': [{'accept': True, 'text': 'foo'},\n{'accept': True, 'text': 'foobar'}]},\n{'annotator': 'b',\n'subset': [{'accept': True, 'text': 'foo'},\n{'accept': True, 'text': 'foobar'}]}\n]\nresult = LazyLines(data).nest_by(\"annotator\")\nassert result.collect() == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def nest_by(self, *keys: str) -&gt; LazyLines:\n\"\"\"\n    Group by keys and return nested collections.\n    The opposite of `.unnest()`\n    Arguments:\n        keys: the keys to nest by\n    **Usage**:\n    ```python\n    from lazylines import LazyLines\n    data = [\n        {'accept': True, 'annotator': 'a', 'text': 'foo'},\n        {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n        {'accept': True, 'annotator': 'b', 'text': 'foo'},\n        {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n    ]\n    expected = [\n            {'annotator': 'a',\n             'subset': [{'accept': True, 'text': 'foo'},\n                        {'accept': True, 'text': 'foobar'}]},\n            {'annotator': 'b',\n             'subset': [{'accept': True, 'text': 'foo'},\n                        {'accept': True, 'text': 'foobar'}]}\n    ]\n    result = LazyLines(data).nest_by(\"annotator\")\n    assert result.collect() == expected\n    ```\n    \"\"\"\ngroups = {}\nfor example in self.g:\nkey = tuple(example.get(arg, None) for arg in keys)\nif key not in groups:\ngroups[key] = []\nfor arg in keys:\ndel example[arg]\ngroups[key].append(example)\nresult = []\nfor key, values in groups.items():\nresult.append({**{k: v for k, v in zip(keys, key)}, \"subset\": values})\nreturn LazyLines(result)\n</code></pre>"},{"location":"api/#lazylines.LazyLines.pipe","title":"<code>pipe(func, *args, **kwargs)</code>","text":"<p>Call a function over the entire generator.</p> Source code in <code>lazylines/__init__.py</code> <pre><code>def pipe(self, func, *args, **kwargs) -&gt; LazyLines:\n\"\"\"Call a function over the entire generator.\"\"\"\nreturn LazyLines(g=func(self, *args, **kwargs))\n</code></pre>"},{"location":"api/#lazylines.LazyLines.progress","title":"<code>progress()</code>","text":"<p>Adds a progress bar. Meant to be used early.</p> <p>Will also run through the entire stream once to calculate the stream size.</p> Source code in <code>lazylines/__init__.py</code> <pre><code>def progress(self) -&gt; LazyLines:\n\"\"\"\n    Adds a progress bar. Meant to be used early.\n    Will also run through the entire stream once to calculate the stream size.\n    \"\"\"\nstream_orig, stream_copy = it.tee(self.g)\ntotal = sum(1 for _ in stream_copy)\nreturn LazyLines(g=tqdm.tqdm(stream_orig, total=total))\n</code></pre>"},{"location":"api/#lazylines.LazyLines.rename","title":"<code>rename(**kwargs)</code>","text":"<p>Rename a few keys in each item.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Dict[str, str]</code> <p>str/str pairs that resemble the new name and old name of a key</p> <code>{}</code> <p>Usage:</p> <pre><code>from lazylines import LazyLines\ndata = [\n{'labeller': 'a', 'text': 'foo'},\n{'labeller': 'a', 'text': 'foobar'},\n{'labeller': 'b', 'text': 'foo'},\n{'labeller': 'b', 'text': 'foobar'}\n]\nexpected = [\n{'annotator': 'a', 'text': 'foo'},\n{'annotator': 'a', 'text': 'foobar'},\n{'annotator': 'b', 'text': 'foo'},\n{'annotator': 'b', 'text': 'foobar'}\n]\nresult = (LazyLines(data).rename(annotator=\"labeller\").collect())\nassert result == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def rename(self, **kwargs: Dict[str, str]) -&gt; LazyLines:\n\"\"\"\n    Rename a few keys in each item.\n    Arguments:\n        kwargs: str/str pairs that resemble the new name and old name of a key\n    Usage:\n    ```python\n    from lazylines import LazyLines\n    data = [\n        {'labeller': 'a', 'text': 'foo'},\n        {'labeller': 'a', 'text': 'foobar'},\n        {'labeller': 'b', 'text': 'foo'},\n        {'labeller': 'b', 'text': 'foobar'}\n    ]\n    expected = [\n        {'annotator': 'a', 'text': 'foo'},\n        {'annotator': 'a', 'text': 'foobar'},\n        {'annotator': 'b', 'text': 'foo'},\n        {'annotator': 'b', 'text': 'foobar'}\n    ]\n    result = (LazyLines(data).rename(annotator=\"labeller\").collect())\n    assert result == expected\n    ```\n    \"\"\"\ndef new_gen():\nfor item in self.g:\nnew_items = {k: item[v] for k, v in kwargs.items()}\nyield {**item, **new_items}\nreturn LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.select","title":"<code>select(*keys)</code>","text":"<p>Only select specific keys from each dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>str</code> <p>the names of the keys to be kept around</p> <code>()</code> <p>Usage:</p> <pre><code>from lazylines import LazyLines\ndata = [\n{'accept': True, 'annotator': 'a', 'text': 'foo'},\n{'accept': True, 'annotator': 'a', 'text': 'foobar'},\n{'accept': True, 'annotator': 'b', 'text': 'foo'},\n{'accept': True, 'annotator': 'b', 'text': 'foobar'}\n]\nexpected = [\n{'annotator': 'a', 'text': 'foo'},\n{'annotator': 'a', 'text': 'foobar'},\n{'annotator': 'b', 'text': 'foo'},\n{'annotator': 'b', 'text': 'foobar'}\n]\nresult = LazyLines(data).select(\"annotator\", \"text\")\nassert result.collect() == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def select(self, *keys: str) -&gt; LazyLines:\n\"\"\"\n    Only select specific keys from each dictionary.\n    Arguments:\n        keys: the names of the keys to be kept around\n    Usage:\n    ```python\n    from lazylines import LazyLines\n    data = [\n        {'accept': True, 'annotator': 'a', 'text': 'foo'},\n        {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n        {'accept': True, 'annotator': 'b', 'text': 'foo'},\n        {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n    ]\n    expected = [\n        {'annotator': 'a', 'text': 'foo'},\n        {'annotator': 'a', 'text': 'foobar'},\n        {'annotator': 'b', 'text': 'foo'},\n        {'annotator': 'b', 'text': 'foobar'}\n    ]\n    result = LazyLines(data).select(\"annotator\", \"text\")\n    assert result.collect() == expected\n    ```\n    \"\"\"\ndef new_gen():\nfor ex in self.g:\nyield {k: v for k, v in ex.items() if k in keys}\nreturn LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.show","title":"<code>show(n=5)</code>","text":"<p>Give a preview of the first <code>n</code> examples. </p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>the number of examples to preview</p> <code>5</code> Source code in <code>lazylines/__init__.py</code> <pre><code>def show(self, n: int=5) -&gt; LazyLines:\n\"\"\"\n    Give a preview of the first `n` examples. \n    Arguments:\n        n: the number of examples to preview\n    \"\"\"\nstream_orig, stream_copy = it.tee(self.g)\nfor _ in range(n):\npprint.pprint(next(stream_copy))\nreturn LazyLines(g=stream_orig)\n</code></pre>"},{"location":"api/#lazylines.LazyLines.sort_by","title":"<code>sort_by(*keys)</code>","text":"<p>Sort the items based on a subset of the keys.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>str</code> <p>the keys to use for sorting</p> <code>()</code> Source code in <code>lazylines/__init__.py</code> <pre><code>def sort_by(self, *keys: str) -&gt; LazyLines:\n\"\"\"\n    Sort the items based on a subset of the keys.\n    Arguments:\n        keys: the keys to use for sorting\n    \"\"\"\nreturn LazyLines(g=sorted(self.g, key=lambda d: tuple([d[c] for c in keys])))\n</code></pre>"},{"location":"api/#lazylines.LazyLines.tee","title":"<code>tee(n=2)</code>","text":"<p>Copies the lazylines.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>how often to <code>tee</code> the stream</p> <code>2</code> <p>Usage:</p> <pre><code>from lazylines import LazyLines\ndata = [\n{'accept': True, 'annotator': 'a', 'text': 'foo'},\n{'accept': True, 'annotator': 'a', 'text': 'foobar'},\n{'accept': True, 'annotator': 'b', 'text': 'foo'},\n{'accept': True, 'annotator': 'b', 'text': 'foobar'}\n]\nlines1, lines2 = LazyLines(data).tee(n=2)\nlines1, lines2, lines3 = LazyLines(data).tee(n=3)\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def tee(self, n:int=2) -&gt; Tuple[LazyLines]:\n\"\"\"\n    Copies the lazylines.\n    Arguments:\n        n: how often to `tee` the stream\n    Usage:\n    ```python\n    from lazylines import LazyLines\n    data = [\n        {'accept': True, 'annotator': 'a', 'text': 'foo'},\n        {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n        {'accept': True, 'annotator': 'b', 'text': 'foo'},\n        {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n    ]\n    lines1, lines2 = LazyLines(data).tee(n=2)\n    lines1, lines2, lines3 = LazyLines(data).tee(n=3)\n    ```\n    \"\"\"\nreturn tuple(LazyLines(g=gen) for gen in it.tee(self.g, n))\n</code></pre>"},{"location":"api/#lazylines.LazyLines.unnest","title":"<code>unnest(key='subset')</code>","text":"<p>Explodes a key, effectively un-nesting it.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the key to un-nest</p> <code>'subset'</code> <p>Usage:</p> <pre><code>from lazylines import LazyLines\ndata = [{'annotator': 'a',\n'subset': [{'accept': True, 'text': 'foo'},\n{'accept': True, 'text': 'foobar'}]},\n{'annotator': 'b',\n'subset': [{'accept': True, 'text': 'foo'},\n{'accept': True, 'text': 'foobar'}]}]\nexpected = [\n{'accept': True, 'annotator': 'a', 'text': 'foo'},\n{'accept': True, 'annotator': 'a', 'text': 'foobar'},\n{'accept': True, 'annotator': 'b', 'text': 'foo'},\n{'accept': True, 'annotator': 'b', 'text': 'foobar'}\n]\nresult = LazyLines(data).unnest(\"subset\")\nassert result.collect() == expected\n</code></pre> Source code in <code>lazylines/__init__.py</code> <pre><code>def unnest(self, key: str=\"subset\") -&gt; LazyLines:\n\"\"\"\n    Explodes a key, effectively un-nesting it.\n    Arguments:\n        key: the key to un-nest\n    **Usage**:\n    ```python\n    from lazylines import LazyLines\n    data = [{'annotator': 'a',\n             'subset': [{'accept': True, 'text': 'foo'},\n                        {'accept': True, 'text': 'foobar'}]},\n            {'annotator': 'b',\n             'subset': [{'accept': True, 'text': 'foo'},\n                        {'accept': True, 'text': 'foobar'}]}]\n    expected = [\n        {'accept': True, 'annotator': 'a', 'text': 'foo'},\n        {'accept': True, 'annotator': 'a', 'text': 'foobar'},\n        {'accept': True, 'annotator': 'b', 'text': 'foo'},\n        {'accept': True, 'annotator': 'b', 'text': 'foobar'}\n    ]\n    result = LazyLines(data).unnest(\"subset\")\n    assert result.collect() == expected\n    ```\n    \"\"\"\ndef new_gen():\nfor item in self.g:\nfor value in item[key]:\norig = {k: v for k, v in item.items() if k != key}\nd = {**{key: value}, **orig}\nyield d\nreturn LazyLines(g=new_gen())\n</code></pre>"},{"location":"api/#lazylines.LazyLines.write_jsonl","title":"<code>write_jsonl(path, append=False, append_new_line=True)</code>","text":"<p>Write everything into a jsonl file.</p> <p>Note that, as a consequence, this will also empty the lazyline object.</p> Source code in <code>lazylines/__init__.py</code> <pre><code>def write_jsonl(\nself, path, append: bool = False, append_new_line: bool = True\n) -&gt; LazyLines:\n\"\"\"\n    Write everything into a jsonl file.\n    Note that, as a consequence, this will also empty the lazyline object.\n    \"\"\"\nsrsly.write_jsonl(path, self.g, append=append, append_new_line=append_new_line)\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>In this section we will show a few examples that use this library. As a motivating example, we will  dive into a subset of the Google Emotions dataset  to dive into annotator agreement.</p> <p>You can download this dataset yourself here. Or you can fetch it via: </p> <pre><code>wget https://raw.githubusercontent.com/koaning/lazylines/main/go_emotions_subset.jsonl\n</code></pre> <p>You can have a look at the first example via:</p> <pre><code>from lazylines import read_jsonl\nread_jsonl(\"go_emotions_subset.jsonl\").show(1)\n</code></pre> <p>Which will show you: </p> <pre><code>{\n'annotations': {'excitement': 0, 'love': 0},\n'rater_id': 1,\n'text': 'That game hurt.',\n'timestamp': 1548381039\n}\n</code></pre> <p>Each example here contains two annotations for a piece of text indicating if an annotator believed that the text contained \"excitement\" or \"love\". The \"text\"  key shows the text in question and the timestamp should be the timestamp of the  annotation.</p>"},{"location":"examples/#agreement-per-item","title":"Agreement per item.","text":"<p>As a first exercise, let's explore how often annotators agree on the examples.  This will involve many steps, but the first step would be to nest by the text key. </p> <pre><code>from lazylines import read_jsonl\nread_jsonl(\"go_emotions_subset.jsonl\").nest_by(\"text\").show(1)\n</code></pre> <p>The data will now be reshaped to include a <code>subset</code> key that's grouped by the <code>text</code> key. </p> <pre><code>{\n'subset': [{'annotations': {'excitement': 0, 'love': 0},\n'rater_id': 1,\n'timestamp': 1548381039},\n{'annotations': {'excitement': 0, 'love': 0},\n'rater_id': 72,\n'timestamp': 1548381039},\n{'annotations': {'excitement': 0, 'love': 0},\n'rater_id': 52,\n'timestamp': 1548381039}],\n'text': 'That game hurt.'\n}\n</code></pre> <p>This is nice first step. But there's a lot of information in the <code>subset</code> that we don't need for now. We won't need the timestamp and we're typically only  interested in a single label at a time. So let's include this knowledge by  selecting only a few columns before we nest. </p> <pre><code>(\nread_jsonl(\"go_emotions_subset.jsonl\")                # point to a file on disk\n.mutate(annot=lambda d: d['annotations']['love'])    # just focus on `love` annotation\n.select(\"text\", \"annot\", \"rater_id\")                 # only care about these keys\n.show(2)                                             # show the first two items\n)\n</code></pre> <p>Here's what the first two examples look like. </p> <pre><code>{'annot': 0, 'rater_id': 1, 'text': 'That game hurt.'}\n{'annot': 1, 'rater_id': 18, 'text': 'Man I love reddit.'}\n</code></pre> <p>When we now nest ...</p> <pre><code>(\nread_jsonl(\"go_emotions_subset.jsonl\")\n.mutate(annot=lambda d: d['annotations']['love'])    # just focus on `love` annotation\n.select(\"text\", \"annot\", \"rater_id\")                 # only care about these keys\n.nest_by(\"text\")                                     # now do the nesting\n.show(2)                                             # show the first two items\n)\n</code></pre> <p>... it looks a bunch cleaner. </p> <pre><code>{\n'subset': [{'annot': 0, 'rater_id': 1},\n{'annot': 0, 'rater_id': 72},\n{'annot': 0, 'rater_id': 52}],\n'text': 'That game hurt.'\n}\n</code></pre>"},{"location":"examples/#using-pipe","title":"Using <code>.pipe</code>","text":"<p>This might be a great time to turn out logic into a function and to re-use that in a <code>.pipe()</code> method. </p> <pre><code>from lazylines import LazyLines\ndef nest_towards_label(lines: LazyLines, label: str):\nreturn (lines\n.mutate(annot=lambda d: d['annotations'][label])\n.select(\"text\", \"annot\", \"rater_id\")\n.nest_by(\"text\")\n)\n(\nread_jsonl(\"go_emotions_subset.jsonl\")\n.pipe(nest_towards_label, label=\"love\")\n.show(1)\n)\n</code></pre> <p>The output is exactly the same, but this improves the readability and re-usability of our code. Next up, let's \"pluck\" out the values that we really care about.</p>"},{"location":"examples/#utility-functions","title":"Utility functions","text":"<p>This might be a good time to start using a utility function to \"pluck\"  the values that we're interested in from the <code>\"subset\"</code> key. When you nest, you keep the keys around. But at this point we might only care about the values of the <code>\"love\"</code> key. </p> <pre><code>(\nread_jsonl(\"go_emotions_subset.jsonl\")\n.pipe(nest_towards_label, label=\"love\")\n.mutate(annot=pluck_from_subset(\"annot\"))\n.show(1)\n)\n</code></pre> <p>This shows: </p> <pre><code>{\n'annot': [0, 0, 0],\n'subset': [{'annot': 0, 'rater_id': 1},\n{'annot': 0, 'rater_id': 72},\n{'annot': 0, 'rater_id': 52}],\n'text': 'That game hurt.'\n}\n</code></pre>"},{"location":"examples/#making-relevant-subsets","title":"Making relevant subsets","text":"<p>We now have a \"annot\" list of values attached to each text, which can use for statistics. But let's only consider looking at items that have at least three annotators. </p> <pre><code>(\nread_jsonl(\"go_emotions_subset.jsonl\")\n.pipe(nest_towards_label, label=\"love\")\n.keep(lambda d: len(d['subset']) &gt;= 3)\n.mutate(annot=pluck_from_subset(\"annot\"))\n.show(1)\n)\n</code></pre> <p>Next, we will add a column that indictes if all annotators agree.  Once we have those two statistics, we won't need the <code>\"subset\"</code>  key around anymore.</p> <pre><code>(\nread_jsonl(\"go_emotions_subset.jsonl\")\n.pipe(nest_towards_label, label=\"love\")\n.keep(lambda d: len(d['subset']) &gt;= 3)\n.mutate(annot=pluck_from_subset(\"annot\"),\nagreement = lambda d: len(set(d['annot'])) == 1)\n.drop(\"subset\")\n.show(1)\n)\n</code></pre> <p>This shows:</p> <pre><code>{'agreement': True, 'annot': [0, 0, 0], 'text': 'That game hurt.'}\n</code></pre> <p>Time for one more <code>nest_by</code>. Let's now nest everything by the <code>\"agreement\"</code> key and use this result to count how many items had full agreement.</p> <pre><code>(\nread_jsonl(\"go_emotions_subset.jsonl\")\n.pipe(nest_towards_label, label=\"love\")\n.keep(lambda d: len(d['subset']) &gt;= 3)\n.mutate(annot=pluck_from_subset(\"annot\"),\nagreement = lambda d: len(set(d['annot'])) == 1)\n.drop(\"subset\")\n.nest_by(\"agreement\")\n.mutate(n=lambda d: len(d['subset']))\n.drop(\"subset\")\n.show(2)\n)\n</code></pre> <p>This results in: </p> <pre><code>{'agreement': True, 'n': 5373}\n{'agreement': False, 'n': 307}\n</code></pre> <p>So it seems, at least on this dataset on this label, that about %5 of all annotators disagree. That's pretty interesting, but let's clean up our code one more time. </p>"},{"location":"examples/#final-cleanup","title":"Final cleanup","text":"<pre><code>from lazylines import LazyLines\ndef nest_towards_label(lines: LazyLines, label: str):\nreturn (lines\n.mutate(annot=lambda d: d['annotations'][label])\n.select(\"text\", \"annot\", \"rater_id\")\n.nest_by(\"text\")\n)\ndef calculate_agreement(lines: LazyLines, min_annotators:int = 3):\nreturn (lines\n.keep(lambda d: len(d['subset']) &gt;= min_annotators)\n.mutate(annot=pluck_from_subset(\"annot\"),\nagreement = lambda d: len(set(d['annot'])) == 1)\n.drop(\"subset\")\n.nest_by(\"agreement\")\n.mutate(n=lambda d: len(d['subset']))\n.drop(\"subset\")\n)\n(\nread_jsonl(\"go_emotions_subset.jsonl\")\n.pipe(nest_towards_label, label = \"love\")\n.pipe(calculate_agreement, min_annotators = 3)\n.show(2)\n)\n</code></pre> <p>This is a pretty nice, and flexible, pipeline! You can change the minimum  number of annotators that you expect or switch the label pretty easily. </p>"}]}